<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.68.3" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <title>软件设计原则及常用设计模式 | Qicz&#39;s Thoughts HUB</title>
  <meta property="og:title" content="软件设计原则及常用设计模式 - Qicz&#39;s Thoughts HUB">
  <meta property="og:type" content="article">
      
  <meta property="article:published_time" content="2019-12-03T22:48:20&#43;08:00">
      
      
  <meta property="article:modified_time" content="2019-12-06T11:16:00&#43;08:00">
      
  <meta name="Keywords" content="[设计原则,设计模式]">
  <meta name="description" content="常见设计原则、设计模式使用场景和注意事项。">
      
  <meta name="author" content="Qicz">
  <meta property="og:url" content="https://izcqi.com/posts/2019/12/03/design-principles-patterns-summary/">
  
  <link rel="shortcut icon" href="https://izcqi.com/favicon.png" />
  

  <meta property="og:title" content="软件设计原则及常用设计模式" />
<meta property="og:description" content="常见设计原则、设计模式使用场景和注意事项。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://izcqi.com/posts/2019/12/03/design-principles-patterns-summary/" />
<meta property="article:published_time" content="2019-12-03T22:48:20+08:00" />
<meta property="article:modified_time" content="2019-12-06T11:16:00+08:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="软件设计原则及常用设计模式"/>
<meta name="twitter:description" content="常见设计原则、设计模式使用场景和注意事项。"/>
<meta name="generator" content="Hugo 0.68.3" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />  
  <link rel="stylesheet" href="https://izcqi.com/css/free.min.css?livereload=1574867372890" media="all">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://izcqi.com/css/styles.css" />
  
  <link href="https://izcqi.com/css/monokai.min.css" rel="stylesheet">
  </head>

<body>
  <div id="container">
    <header-container>
    <header>
      <h1>
        <a href="https://izcqi.com/">Qicz&rsquo;s Thoughts HUB</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="mailto:zcq#zhucongqi.cn" title="Email me" target="_blank">
               <i class="fas fa-envelope fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://github.com/qicz" title="GitHub" target="_blank">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://weibo.com/powerlinux" title="Weibo" target="_blank">
               <i class="fab fa-weibo fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://douban.com/people/podevor" title="Douban" target="_blank">
               <i class="fab fa-spotify fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>The creative and technical writing. <!-- raw HTML omitted --> Do more, challenge more, know more, be more.</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://izcqi.com/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>
  </header-container>
    <main>




<article>

    <h1>软件设计原则及常用设计模式</h1>

    
        <aside>
    
    <span class="fa fa-calendar"><time class="post-date" datetime="2019-12-03T22:48:20&#43;08:00"> Dec 3, 2019 22:48</time>
    &nbsp; | &nbsp; 
    
    <span class="fa fa-book">
        <em class="categories">
            
                
                <a href="https://izcqi.com/categories/design-patterns">design-patterns</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
     
    <span class="fa fa-tags">
        <em class="tags">
            
                
                <a href="https://izcqi.com/tags/design-patterns">#design-patterns</a>
            
                , 
                <a href="https://izcqi.com/tags/design-principle">#design-principle</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
    <span class="fa fa-plane"><em> 2 minutes read</em> </span>
</aside>
    

    
    <nav id="TableOfContents">
  <ul>
    <li><a href="#设计原则总结">设计原则总结</a></li>
  </ul>

  <ul>
    <li><a href="#工厂模式">工厂模式</a></li>
    <li><a href="#单例模式-singleton-pattern">单例模式 Singleton Pattern</a></li>
    <li><a href="#原型模式prototype-pattern">原型模式Prototype Pattern</a></li>
    <li><a href="#代理模式-proxy-pattern">代理模式 Proxy Pattern</a></li>
    <li><a href="#委派模式-delegate-pattern">委派模式 Delegate Pattern</a></li>
    <li><a href="#策略模式-strategy-pattern">策略模式 Strategy Pattern</a></li>
    <li><a href="#模板模式-template-pattern模板方法模式template-method-pattern">模板模式 Template Pattern/模板方法模式Template Method Pattern</a></li>
    <li><a href="#适配器模式-adapter-pattern">适配器模式 Adapter Pattern</a></li>
    <li><a href="#装饰器模式-decorator-pattern">装饰器模式 Decorator Pattern</a></li>
    <li><a href="#装饰者与适配器对比">装饰者与适配器对比</a></li>
    <li><a href="#观察者模式-observer-pattern发布订阅模式-pubsub">观察者模式 Observer Pattern/发布订阅模式 Pub/Sub</a></li>
    <li><a href="#各种模式的对比">各种模式的对比</a></li>
    <li><a href="#设计模式总结">设计模式总结</a></li>
  </ul>
</nav>

    <h1 id="软件设计原则">软件设计原则</h1>
<ul>
<li>开闭原则 Open-Closed Principle, OCP</li>
</ul>
<blockquote>
<p>软件实体如类、模块和函数应该对扩展开放，对修改关闭。 所谓的开闭，也正是对扩展和修改两个行为的一个原则。**用抽象构建框架，用实现扩展细节。**可提高软件系统的可复用性和可维护性。</p>
</blockquote>
<ul>
<li>单一职责原则 Simple Responsibility Principle，SRP</li>
</ul>
<blockquote>
<p>不要存在多于一个导致类变更的原因。如有一个 Class 负责两个职责，一旦发生需求变化，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障——这个 Class 就存在了两个导致类变更的因素。此时，我们就需要给两个职责分别用两个 Class 来实现，实现解耦职责的清晰拆分。后期的需要变更维护互不影响。如此设计，可降低类的复杂度，提高类的可读性，提高系统的可维护性，降低变更引起的风险。<strong>一个 Class/Interface/Method只负责一项职能.</strong></p>
</blockquote>
<ul>
<li>依赖倒置原则 Dependence Inversion Principle，DIP</li>
</ul>
<blockquote>
<p>设计代码结构时，高层模块不应该依赖底层模块，二者都应该是依赖其抽象。**抽象不应依赖细节；细节应该依赖抽象。**通过依赖倒置，可减少类与类的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并可以降低修改程序所造成的风险。【<strong>依赖注入</strong>】</p>
</blockquote>
<ul>
<li>接口隔离原则 Interface Segregation Principle，ISP</li>
</ul>
<blockquote>
<p>使用多个专门的接口，而不是用一个单一的总接口，客户端不应该依赖它不需要的接口。符合 <strong>高内聚低耦合</strong>，使得类具有很好的可读性、可扩展性和可维护性。
设计时应注意</p>
<ul>
<li>一个类对一类的依赖应该建立在最小的接口之上；</li>
<li>建立单一接口，不要建立炮打臃肿的接口；</li>
<li>尽量细化接口，接口中的方法尽量少（不是越少越好，适度）</li>
</ul>
</blockquote>
<ul>
<li>迪米特法则 Law of Demeter ，LoD / 最少知道原则（Least Knowledge Principle，LKP）</li>
</ul>
<blockquote>
<p>一个对象应该对其他对象保持最少的了解。尽量降低类与类之间的耦合。**主要强调只和朋友交流，不和陌生人说话。**出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</p>
</blockquote>
<ul>
<li>里氏替换原则 Liskov Substitution Principle，LSP</li>
</ul>
<blockquote>
<p>如果每一个类型为 T1 的对象 o1都有类型为 T2 的对应 o2，使用以 T1 定义的所有程序 P 在所有的对象 o1都替换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类。
一个软件实体如果适用于一个父类的话，那么一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而不影响程序原来的逻辑。<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p>
<ol>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>
<li>子类中可以增加自己特有的方法；</li>
<li>当子类的方法重载Overloading父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松；</li>
<li>当子类的方法实现父类的方式时（重写 Override/重载 Overloading 或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等。</li>
</ol>
<p><strong>某种情况下会违背开闭原则。</strong>
该原则的优点：</p>
<ol>
<li>约束继承泛滥，开闭原则的一种体现；</li>
<li>加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性，降低需要变更时引入的风险。</li>
</ol>
</blockquote>
<ul>
<li>合成复用原则 Composite/Aggregate Reuse Principle，CARP</li>
</ul>
<blockquote>
<p>尽量使用对象组合（Has-a）/聚合（Contain-a），而不是继承关系达到软件复用的目的。可以使用系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。<strong>继承：白箱复用</strong>，相当于把所有的实现细节暴露给子类。<strong>组合/聚合：黑箱复用</strong>，对类以外的对象是无法获取到其实现细节的。</p>
</blockquote>
<h2 id="设计原则总结">设计原则总结</h2>
<blockquote>
<p>在实际开发中，并不是一定要求所有代码都遵循设计原则，要在适当的场景遵循设计原则，体现一种平衡取舍。</p>
</blockquote>
<h1 id="设计模式">设计模式</h1>
<h2 id="工厂模式">工厂模式</h2>
<ul>
<li><strong>简单工厂模式 Simple Factory Pattern</strong>
<ul>
<li>由一个工厂对象决定创建出哪一种产品类的实例；</li>
<li>创建型模式，不属于 GOF(The authors Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides are often referred to as the GoF, or Gang of Four.)23 中设计模式；</li>
<li>适用场景：
<ul>
<li>工厂类负责创建的对象较少；</li>
<li>客户端只需要传入工厂类的参数，对应如何创建对象的逻辑不需要关系。</li>
</ul>
</li>
<li>优点：
<ul>
<li>只需传入一个正确的参数，就可以获取你所需要的对应，无须知道其创建的细节。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>工厂类职责过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则；</li>
<li>不易于扩展过于复杂的产品结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>eg:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>Logger<span style="color:#ff79c6">.</span><span style="color:#50fa7b">getLogger</span><span style="color:#ff79c6">(</span>ClassName<span style="color:#ff79c6">)</span>
</code></pre></div><ul>
<li><strong>工厂方法模式 Factory Method Pattern</strong>
<ul>
<li>定义一个创建对象的接口，让实现这个接口的类自己来决定实例化哪个类，工厂方法让类的实例化推迟到到子类中进行；</li>
<li>创建型模式。</li>
<li>使用场景：
<ul>
<li>创建对象需要大量重复的代码；</li>
<li>客户端（应用层）不依赖产品类实例如何创建、实现等细节；</li>
<li>一个类通过其子类来指定创建哪个对象。</li>
</ul>
</li>
<li>优点：
<ul>
<li>用户只需要管理所需产品对应的工厂，无须关心创建细节；</li>
<li>加入新的产品符合开闭原则，提高了系统的可扩展性。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>类的个人易变得过多，增加了代码结构的复杂度；</li>
<li>增加了系统的抽象性和理解难度。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>VS <strong>简单工厂模式</strong>，遵循开闭原则，增加新的产品时，有对应的产品的子工厂去完成。</p>
</blockquote>
<ul>
<li><strong>抽象工程模式 Abstract Factory Pattern</strong>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，无须指定他们的具体的类；<strong>(在设计规则时，具体的业务逻辑都还未确定的情况，具体实现依靠工厂，高度抽象的工厂)</strong></li>
<li>创建型设计模式。</li>
<li>适用场景：
<ul>
<li>客户端（应用层）不依赖产品类实现如何被创建、实现等细节；<strong>（与工厂方法模式有相同处）</strong></li>
<li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码；</li>
<li>提供一个产品类的库，所有产品以同样的接口出现，从而使客户端不依赖于具体实现。</li>
</ul>
</li>
<li>优点：
<ul>
<li>具体产品在应用层代码隔离，无须关心创建细节；</li>
<li>将一个系列的产品族统一到一起创建。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口；</li>
<li>增加了系统的抽象性和理解难度；<strong>（与工厂方法模式有相同处）</strong></li>
<li>不符合开闭原则，顶级工厂在新增产品时，需要修改其实现，而这样修改会影响子工厂的变动。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="单例模式-singleton-pattern">单例模式 Singleton Pattern</h2>
<p>点击查看 &raquo; <a href="https://izcqi.com/posts/201912/02/design-patterns-singleton/">单例模式</a> &laquo;</p>
<h2 id="原型模式prototype-pattern">原型模式Prototype Pattern</h2>
<ul>
<li>原型实例指定创建对象的种类，通过靠谱这些原型创建新的对象</li>
<li>调用者无须知道任何创建细节，不用调用构造函数</li>
<li>创建型模式</li>
<li>适用场景
<ul>
<li>类初始化消耗资源较多</li>
<li>new产生的一个对象需要繁琐的过程（数据准备，访问权限等）</li>
<li>构造函数较复杂</li>
<li>循环体中生产大量对象</li>
</ul>
</li>
</ul>
<h2 id="代理模式-proxy-pattern">代理模式 Proxy Pattern</h2>
<ul>
<li>造成系统设计中类的数目增加</li>
<li>客户端与目标对象（委托类）之间加了一个代理对象（代理类），造成请求处理速度变慢</li>
<li>增加系统的复杂度</li>
</ul>
<h2 id="委派模式-delegate-pattern">委派模式 Delegate Pattern</h2>
<ul>
<li>精简程序逻辑，提升代码可读性</li>
<li>全权静态代理</li>
<li>不属于 GOF23 之一</li>
<li>行为型模式</li>
<li>命名含：Delegate或Dispatcher</li>
</ul>
<p>eg:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1</span>HttpServlet
</code></pre></div><h2 id="策略模式-strategy-pattern">策略模式 Strategy Pattern</h2>
<ul>
<li>定义了算法家族、分别封装起来，让它们之间可以相互替换，此模式让算法的变化不会影响到使用算法的用户；</li>
<li>消除程序中大量的if&hellip;else&hellip; 和switch语句。</li>
<li><strong>提供给用户选择，关心的是结果，不能干预逻辑和流程，只有选择权和干预权。</strong></li>
<li>优点：
<ul>
<li>符合开闭原则；</li>
<li>避免使用多重条件转移原件，if&hellip;else&hellip;语句、switch 语句 ；</li>
<li>提高算法的保密性和安全性。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类；</li>
<li>代码中会产生非常多策略类，增加维护难度。</li>
</ul>
</li>
</ul>
<h2 id="模板模式-template-pattern模板方法模式template-method-pattern">模板模式 Template Pattern/模板方法模式Template Method Pattern</h2>
<ul>
<li>适用场景
<ul>
<li>一次性实现一个算法的不变部分，将可变的行为留给子类来实现；</li>
<li>各子类中公共的行为被提取出来并集中到一个公共的父类中，避免代码的重复。</li>
</ul>
</li>
<li>钩子方法：控制流程的方法，交给子类去动态控制。</li>
<li><strong>关心的是流程，对流程可进行微调，有干预权，可干预内在逻辑。</strong></li>
<li>优点：
<ul>
<li>提高代码的复用性；</li>
<li>提高代码的扩展性；</li>
<li>符合开闭原则。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>类数目增加；</li>
<li>间接的增加了系统实现的复杂度；</li>
<li>继承关系的自身缺点，如父类添加新的抽象方法，所有子类都需要改一遍。</li>
</ul>
</li>
</ul>
<h2 id="适配器模式-adapter-pattern">适配器模式 Adapter Pattern</h2>
<ul>
<li>
<p>一个类的接口转化成客户期望的另一个接口，使原本的接口不兼容（<strong>support</strong>）的类可以一起工作。</p>
</li>
<li>
<p>结构型设计模式。</p>
</li>
<li>
<p>适用场景：</p>
<ul>
<li>已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况；</li>
<li>适配器模式不是软件设计阶段需要考虑的设计模式，是随着软件维护由于不同产品、不同厂家造成功能类似而接口不相同情况下的解决方案。</li>
</ul>
</li>
<li>
<p>有点类似<strong>静态代理</strong></p>
</li>
<li>
<p>优点：</p>
<ul>
<li>提高类的透明性和复用，现有的类复用但不需要改变；</li>
<li>目标类和适配器类解耦，提供程序的扩展性；</li>
<li>在很多业务场景中符合开闭原则。</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>适配器编写过程需要全面考虑，可能会增加系统的复杂性；</li>
<li>增加代码的阅读难度，降低代码可读性，过度使用适配器会使系统代码变得凌乱。</li>
</ul>
</li>
</ul>
<h2 id="装饰器模式-decorator-pattern">装饰器模式 Decorator Pattern</h2>
<ul>
<li><strong>对象组合（Has-a）/聚合（Contain-a）</strong>？？</li>
<li>比继承更具弹性</li>
<li>优点：
<ul>
<li>继承的有力补充，比继承灵活，不改变原有对象的情况下动态地给一个对象扩展功能，即插即用；</li>
<li>通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果；</li>
<li>装饰者完全遵守开闭原则。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>会出现更多的代码，更多的类，增加程序复杂性；</li>
<li>动态装饰时，多层装饰时会更复杂。</li>
</ul>
</li>
</ul>
<h2 id="装饰者与适配器对比">装饰者与适配器对比</h2>
<table>
<thead>
<tr>
<th>装饰者模式Decorator</th>
<th>适配器模式Adapter</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>形式</td>
<td>有对应的层级关系，一种非常特别的适配器模式</td>
<td>没有层级关系</td>
</tr>
<tr>
<td>定义</td>
<td>装饰者和被装饰者都实现同一个接口，主要目的是为了扩展之后依旧保留 OOP 关系</td>
<td>适配器和被适配者没有必然的联系，通常是采用继承或者代理的形式进行包装</td>
</tr>
<tr>
<td>关系</td>
<td>满足 is-a 的关系</td>
<td>满足 has-a 的关系</td>
</tr>
<tr>
<td>功能</td>
<td>注重覆盖、扩展</td>
<td>注重兼容、装换</td>
</tr>
<tr>
<td>设计</td>
<td>前置考虑</td>
<td>后置考虑，到了一定的情况下，再去考虑“亡羊补牢”的感觉</td>
</tr>
</tbody>
</table>
<h2 id="观察者模式-observer-pattern发布订阅模式-pubsub">观察者模式 Observer Pattern/发布订阅模式 Pub/Sub</h2>
<ul>
<li>行为型模式；</li>
<li>优点：
<ul>
<li>观察者 observer 和被观察者 observable之间建立了一个抽象的耦合；</li>
<li>观察者模式支持广播通信。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>观察者之间有过多的细节依赖、提高时间消耗及程序的复杂度；</li>
<li>使用要得当，要避免循环调用。</li>
</ul>
</li>
</ul>
<h2 id="各种模式的对比">各种模式的对比</h2>
<ul>
<li>单例和工厂模式</li>
</ul>
<blockquote>
<p>工厂一般会设计为单例，ApplicationContext</p>
</blockquote>
<ul>
<li>策略和工厂模式</li>
</ul>
<blockquote>
<ol>
<li>工厂模式包含工厂方法和抽象工厂，属于创建型模式（new）；策略模式属于行为模式（invoke）</li>
</ol>
<ul>
<li>工厂模式主要目的是封装好创建逻辑，策略模式接收工厂创建好的对象，从而实现不同的行为。</li>
</ul>
</blockquote>
<ul>
<li>策略和委派模式</li>
</ul>
<blockquote>
<ol>
<li>策略模式是委派模式内部的一种实现形式，其关注的是结果是否能相互替代；<strong>比如支付方式：Alipay，WechatPay，JDPay 等。</strong></li>
</ol>
<ul>
<li>委派模式更关注份分发和调度的过程。<strong>有可能采用 if&hellip;else&hellip;条件分支语句来分发，内部也可以使用策略模式。</strong></li>
</ul>
</blockquote>
<ul>
<li>模板方法和工厂方法模式</li>
</ul>
<blockquote>
<ol>
<li>工厂方法是模板方法的一种特殊实现；</li>
</ol>
<ul>
<li>工厂方法只有一个步骤，是模板模式的特殊实现；</li>
<li>模板模式其执行流程在父类已固化，不可变动。同时，子类实现的是父类的某一个步骤，也就是说子类可能有多个对父类具体步骤的完善。</li>
</ul>
</blockquote>
<ul>
<li>模板和策略模式</li>
</ul>
<blockquote>
<ol>
<li>模板方法和策略都有封装算法；</li>
</ol>
<ul>
<li>策略是使不同算法可以相互替换，且不影响客户端应用层的使用；</li>
<li>模板方法是针对定义一个算法的流程，将一些有细微差异的部分交给子类实现，不可被替换；</li>
<li>模板模式不能改变算法流程，策略模式可以改变算法流程且可替换，策略模式通常用来代替 if&hellip;else&hellip;等条件分支语句。</li>
</ul>
</blockquote>
<ul>
<li>装饰者和静态代理模式</li>
</ul>
<blockquote>
<ol>
<li>装饰者模式关注点在于给对象动态扩展、添加方法，而代理更加注重控制对对象的访问；</li>
</ol>
<ul>
<li>代理模式通常会在代理类中创建被代理对象的实例，而装饰者模式通常把被装饰者作为构成参数。</li>
</ul>
</blockquote>
<ul>
<li>装饰者和适配器模式</li>
</ul>
<blockquote>
<ol>
<li>装饰者模式和适配器模式都属于包装器模式（Wrapper）；</li>
</ol>
<ul>
<li>装饰者模式可以实现被装饰者与相同的接口或者继承被装饰者作为它的子类，而适配器和呗适配者可以实现不同的接口。</li>
</ul>
</blockquote>
<ul>
<li>适配器和策略模式</li>
</ul>
<blockquote>
<p>在适配业务复杂的情况下，利用策略模式优化动态适配逻辑。</p>
</blockquote>
<h2 id="设计模式总结">设计模式总结</h2>
<table>
<thead>
<tr>
<th>设计模式Pattern</th>
<th>一句话</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>工厂模式Factory</td>
<td>只对结果负责，封装创建过程。</td>
<td>BeanFactory、Calendar</td>
</tr>
<tr>
<td>单例模式 Singleton</td>
<td>保证独一无二</td>
<td>ApplicationContext、Calendar</td>
</tr>
<tr>
<td>原型模式 Prototype</td>
<td>拔一根猴毛，吹出千万个(多例模式)</td>
<td>ArrayList、PrototypeBean</td>
</tr>
<tr>
<td>代理模式 Proxy</td>
<td>宅人办事，增强职责</td>
<td>ProxyFactoryBean、JdkDynamicAopProxy、CglibAopProxy</td>
</tr>
<tr>
<td>委派模式 Delegate</td>
<td>干活算你的（普通员工），功劳算我的（项目经理）</td>
<td>DIspatcherServlet、BeanDefinitionPaserDelegate</td>
</tr>
<tr>
<td>策略模式 Strategy</td>
<td>用户选择，结果统一</td>
<td>InstantiationStrategy</td>
</tr>
<tr>
<td>模板模式 Template</td>
<td>流程标准化、自己实现定制</td>
<td>JdbcTemplate、HttpServlet</td>
</tr>
<tr>
<td>适配器 Adapter</td>
<td>兼容转换头</td>
<td>AdvisorAdapter、HandlerAdapter</td>
</tr>
<tr>
<td>装饰器模式 Decorator</td>
<td>包装、同宗同源</td>
<td>BufferReader、InputStream、OutputStream、HttpHeadResponseDecorator</td>
</tr>
<tr>
<td>观察值模式 Observer</td>
<td>任务完成时通知</td>
<td>ContextLoaderListener</td>
</tr>
</tbody>
</table>


</article>


<script src="https://utteranc.es/client.js"
    repo="qicz/ThoughtsHUB"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>

<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://izcqi.com/posts/2019/12/02/distributed-platform-design-principles/"><i class="fa fa-chevron-circle-left"></i> 分布式系统/高并发系统设计原则</a>
        </li>
        
        
        <li>
            <a href="https://izcqi.com/posts/2019/12/08/generate-gitigore-file/">快速的生成你需要的.gitignore文件 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    




</main>
    <footer>
        <h6>© 2012 - 2021 Qicz 
            - Qicz&#39;s Thoughts HUB (<a href="https://izcqi.com/"> https://izcqi.com</a>)
            | Theme <a href="https://github.com/qicz/qicz-hugo-theme">qicz-theme</a>
            | This site USES <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></h6>
    </footer>
</div>

<script async src="https://izcqi.com/js/busuanzi.pure.mini.js"></script>

</body>

</html>

