<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.59.1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <title>MyBatis Plugin工作机理 | Qicz&#39;s Thoughts HUB</title>
  <meta property="og:title" content="MyBatis Plugin工作机理 - Qicz&#39;s Thoughts HUB">
  <meta property="og:type" content="article">
      
  <meta property="article:published_time" content="2019-12-09T22:00:43&#43;08:00">
      
      
  <meta property="article:modified_time" content="2019-12-10T14:00:43&#43;08:00">
      
  <meta name="Keywords" content="Qicz,Jobsz,RD,technology,tech,learning,设计模式,分布式,架构设计,P6,P7,软件设计,数据库,大数据,MySQL,Zookeeper,MongoDB,redis,dubbo,ServiceMesh,SOFAMesh,Serverless,hugo,Java,Mybatis,Spring,Spring Boot,Spring Cloud,istio">
  <meta name="description" content="MyBatis Plugin工作机理">
      
  <meta name="author" content="Qicz">
  <meta property="og:url" content="https://izcqi.com/posts/2019/12/09/mybatis-plugins-principle/">
  
  <link rel="shortcut icon" href="https://izcqi.com/favicon.png" />
  

  <meta property="og:title" content="MyBatis Plugin工作机理" />
<meta property="og:description" content="故事开头： 在使用MyBatis的RowBounds时，发现结果没有和理论的一致，然后深入研究RowBounds的实现原理：MyBatis仅借助RowBounds在内存中完成了数据的分页处理——逻辑分页。还有一种是物理分页，就是常见的Limit offset, limit的方式（MySQL）。然后查资料，研究找到了很多的实现方式。我先尝试了一下其中的一种：使用Interceptor的方式。大体的逻辑是在当前执行的SQL后面把RowBounds的offset，limit按照limit offset,limit的方式拼接在SQL后面。
实现如下：
@Intercepts({@Signature(type = Executor.class, method = &#34;query&#34;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})}) public class PageInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { Object[] args = invocation." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://izcqi.com/posts/2019/12/09/mybatis-plugins-principle/" />
<meta property="article:published_time" content="2019-12-09T22:00:43+08:00" />
<meta property="article:modified_time" content="2019-12-10T14:00:43+08:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MyBatis Plugin工作机理"/>
<meta name="twitter:description" content="故事开头： 在使用MyBatis的RowBounds时，发现结果没有和理论的一致，然后深入研究RowBounds的实现原理：MyBatis仅借助RowBounds在内存中完成了数据的分页处理——逻辑分页。还有一种是物理分页，就是常见的Limit offset, limit的方式（MySQL）。然后查资料，研究找到了很多的实现方式。我先尝试了一下其中的一种：使用Interceptor的方式。大体的逻辑是在当前执行的SQL后面把RowBounds的offset，limit按照limit offset,limit的方式拼接在SQL后面。
实现如下：
@Intercepts({@Signature(type = Executor.class, method = &#34;query&#34;, args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})}) public class PageInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { Object[] args = invocation."/>
<meta name="generator" content="Hugo 0.59.1" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />  
  <link rel="stylesheet" href="https://izcqi.com/css/free.min.css?livereload=1574867372890" media="all">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://izcqi.com/css/styles.css" />
  
  <link href="https://izcqi.com/css/monokai.min.css" rel="stylesheet">
  </head>

<body>
  <div id="container">
    <header-container>
    <header>
      <h1>
        <a href="https://izcqi.com/">Qicz&rsquo;s Thoughts HUB</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="mailto:zcq#zhucongqi.cn" title="Email me" target="_blank">
               <i class="fas fa-envelope fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://www.facebook.com/qiczhu" title="Facebook" target="_blank">
               <i class="fab fa-facebook fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://github.com/qicz" title="GitHub" target="_blank">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://reddit.com/u/Qiczhu" title="Reddit" target="_blank">
               <i class="fab fa-reddit-alien fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://weibo.com/powerlinux" title="Weibo" target="_blank">
               <i class="fab fa-weibo fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://douban.com/people/podevor" title="Douban" target="_blank">
               <i class="fab fa-spotify fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>The creative and technical writing.</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://izcqi.com/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>
  </header-container>
    <main>




<article>

    <h1>MyBatis Plugin工作机理</h1>

    
        <aside>
    
    <span class="fa fa-calendar"><time class="post-date" datetime="2019-12-09T22:00:43&#43;08:00"> Dec 9, 2019 22:00</time>
    &nbsp; | &nbsp; 
    
    <span class="fa fa-book">
        <em class="categories">
            
                
                <a href="https://izcqi.com/categories/db">db</a>
            
                , 
                <a href="https://izcqi.com/categories/mybatis">mybatis</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
     
    <span class="fa fa-tags">
        <em class="tags">
            
                
                <a href="https://izcqi.com/tags/mybatis">#mybatis</a>
            
                , 
                <a href="https://izcqi.com/tags/db">#db</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
    <span class="fa fa-plane"><em> 3 minutes read</em> </span>
</aside>


    

    <p>故事开头：
在使用MyBatis的RowBounds时，发现结果没有和理论的一致，然后深入研究RowBounds的实现原理：<strong>MyBatis仅借助RowBounds在内存中完成了数据的分页处理——逻辑分页</strong>。还有一种是<strong>物理分页</strong>，就是常见的Limit offset, limit的方式（MySQL）。然后查资料，研究找到了很多的实现方式。我先尝试了一下其中的一种：使用Interceptor的方式。大体的逻辑是在当前执行的SQL后面把RowBounds的offset，limit按照<strong>limit offset,limit</strong>的方式拼接在SQL后面。</p>

<p>实现如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Intercepts({@Signature(type <span style="color:#ff79c6">=</span> Executor.<span style="color:#50fa7b">class</span>, method <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;query&#34;</span>, args <span style="color:#ff79c6">=</span> {MappedStatement.<span style="color:#50fa7b">class</span>, Object.<span style="color:#50fa7b">class</span>, RowBounds.<span style="color:#50fa7b">class</span>, ResultHandler.<span style="color:#50fa7b">class</span>})})
public class PageInterceptor implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        Object[] args <span style="color:#ff79c6">=</span> invocation.<span style="color:#50fa7b">getArgs</span>();
        MappedStatement ms <span style="color:#ff79c6">=</span> (MappedStatement) args[0]; <span style="color:#6272a4">// MappedStatement
</span><span style="color:#6272a4"></span>        BoundSql boundSql <span style="color:#ff79c6">=</span> ms.<span style="color:#50fa7b">getBoundSql</span>(args[1]); <span style="color:#6272a4">// Object parameter
</span><span style="color:#6272a4"></span>        RowBounds rb <span style="color:#ff79c6">=</span> (RowBounds) args[2]; <span style="color:#6272a4">// RowBounds
</span><span style="color:#6272a4"></span>        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> rb <span style="color:#ff79c6">||</span> rb <span style="color:#ff79c6">==</span> RowBounds.<span style="color:#50fa7b">DEFAULT</span>) {
            <span style="color:#ff79c6">return</span> invocation.<span style="color:#50fa7b">proceed</span>();
        }

        <span style="color:#6272a4">// append limit statement
</span><span style="color:#6272a4"></span>        StringBuilder sqlBuidler <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> StringBuilder(boundSql.<span style="color:#50fa7b">getSql</span>());
        String limit <span style="color:#ff79c6">=</span> String.<span style="color:#50fa7b">format</span>(<span style="color:#f1fa8c">&#34; limit %d,%d&#34;</span>, rb.<span style="color:#50fa7b">getOffset</span>(), rb.<span style="color:#50fa7b">getLimit</span>());
        sqlBuidler.<span style="color:#50fa7b">append</span>(limit);

        <span style="color:#6272a4">// replace sqlSource by reflection
</span><span style="color:#6272a4"></span>        SqlSource sqlSource <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> StaticSqlSource(ms.<span style="color:#50fa7b">getConfiguration</span>(), sqlBuidler.<span style="color:#50fa7b">toString</span>(), boundSql.<span style="color:#50fa7b">getParameterMappings</span>());
        Field field <span style="color:#ff79c6">=</span> MappedStatement.<span style="color:#50fa7b">class</span>.<span style="color:#50fa7b">getDeclaredField</span>(<span style="color:#f1fa8c">&#34;sqlSource&#34;</span>);
        field.<span style="color:#50fa7b">setAccessible</span>(<span style="color:#ff79c6">true</span>);
        field.<span style="color:#50fa7b">set</span>(ms, sqlSource);
        <span style="color:#ff79c6">return</span> invocation.<span style="color:#50fa7b">proceed</span>();
    }

    @Override
    public Object plugin(Object target) {
        <span style="color:#ff79c6">return</span> Plugin.<span style="color:#50fa7b">wrap</span>(target, <span style="color:#ff79c6">this</span>);
    }

    @Override
    public void setProperties(Properties properties) {

    }
}</code></pre></div>
<p>别忘记在<strong>mybatis-config.xml</strong>中配置plugins：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-xml" data-lang="xml">  <span style="color:#ff79c6">&lt;plugins&gt;</span>
        <span style="color:#ff79c6">&lt;plugin</span> <span style="color:#50fa7b">interceptor=</span><span style="color:#f1fa8c">&#34;cn.zhucongqi.interceptor.PageInterceptor&#34;</span><span style="color:#ff79c6">/&gt;</span>
  <span style="color:#ff79c6">&lt;/plugins&gt;</span></code></pre></div>
<p>然后测试，成功了。</p>

<p>那么下面问题来了？这Interceptor是如何工作的，工作原理是什么？ 然后就开始打断点跟踪如何实现的，然后一步步发现了MyBatis设计真的精妙得很哟。</p>

<p>正式进入正题，来说说Interceptor的工作原理。</p>

<p>Interceptor字面意思是拦截器，在很多得很有用应用。顾名思义，就是在do一件事之前先拦截一下，所以我们再做物理分页时，才有机会去干预，去拼接SQL。</p>

<p>从MyBatis-config.xml的配置文件来看，其属于MyBatis的Plugin范畴。</p>

<p>所以研究Plugin成为了重头戏。</p>

<p>从SqlSession入手，openSession时在DefaultSqlSessionFactory的私有方法<strong>openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit)</strong>中有这样一段代码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> final Executor executor <span style="color:#ff79c6">=</span> configuration.<span style="color:#50fa7b">newExecutor</span>(tx, execType);</code></pre></div>
<p>这段代码成了一个开头。再深入卡一下newExecutor的实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
	<span style="color:#6272a4">// 确保ExecutorType合法
</span><span style="color:#6272a4"></span>    executorType <span style="color:#ff79c6">=</span> executorType <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span> <span style="color:#ff79c6">?</span> defaultExecutorType <span style="color:#ff79c6">:</span> executorType;
    executorType <span style="color:#ff79c6">=</span> executorType <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span> <span style="color:#ff79c6">?</span> ExecutorType.<span style="color:#50fa7b">SIMPLE</span> <span style="color:#ff79c6">:</span> executorType;
    Executor executor;
    <span style="color:#ff79c6">if</span> (ExecutorType.<span style="color:#50fa7b">BATCH</span> <span style="color:#ff79c6">==</span> executorType) { <span style="color:#6272a4">// 如果是Batch类型选择BatchExecutor
</span><span style="color:#6272a4"></span>      executor <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BatchExecutor(<span style="color:#ff79c6">this</span>, transaction);
    } <span style="color:#ff79c6">else</span> <span style="color:#ff79c6">if</span> (ExecutorType.<span style="color:#50fa7b">REUSE</span> <span style="color:#ff79c6">==</span> executorType) { <span style="color:#6272a4">// 如果是Reuse类型选择ReuseExecutor
</span><span style="color:#6272a4"></span>      executor <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> ReuseExecutor(<span style="color:#ff79c6">this</span>, transaction);
    } <span style="color:#ff79c6">else</span> {
      executor <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> SimpleExecutor(<span style="color:#ff79c6">this</span>, transaction);<span style="color:#6272a4">// 否则是默认的SimpleExecutor
</span><span style="color:#6272a4"></span>    }
    <span style="color:#ff79c6">if</span> (cacheEnabled) {
      executor <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> CachingExecutor(executor); <span style="color:#6272a4">// 二级缓存，用CachingExecutor包装一下
</span><span style="color:#6272a4"></span>    }
    <span style="color:#6272a4">// 这里⬇️重要了
</span><span style="color:#6272a4"></span>    executor <span style="color:#ff79c6">=</span> (Executor) interceptorChain.<span style="color:#50fa7b">pluginAll</span>(executor);
    <span style="color:#ff79c6">return</span> executor;
  }</code></pre></div>
<p>重点就在这里了<code>executor = (Executor) interceptorChain.pluginAll(executor);</code>。</p>

<p>再看看这里做了什么？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">  public Object pluginAll(Object target) {
    <span style="color:#ff79c6">for</span> (Interceptor interceptor <span style="color:#ff79c6">:</span> interceptors) {
      target <span style="color:#ff79c6">=</span> interceptor.<span style="color:#50fa7b">plugin</span>(target);
    }
    <span style="color:#ff79c6">return</span> target;
  }</code></pre></div>
<p>好像又找到了一线索，这个的plugin方法和PageInterceptor中的plugin方法很像？看调用关系，果然就是它。</p>

<p>那么Plugin成了下一个线索。然后发现Plugin implements InvocationHandler，看来Proxy了。往下走，先来看看Plugin.wrap其实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public static Object wrap(Object target, Interceptor interceptor) {
    Map<span style="color:#ff79c6">&lt;</span>Class<span style="color:#ff79c6">&lt;?&gt;</span>, Set&lt;Method&gt;&gt; signatureMap <span style="color:#ff79c6">=</span> getSignatureMap(interceptor);
    Class<span style="color:#ff79c6">&lt;?&gt;</span> type <span style="color:#ff79c6">=</span> target.<span style="color:#50fa7b">getClass</span>();
    Class<span style="color:#ff79c6">&lt;?&gt;</span>[] interfaces <span style="color:#ff79c6">=</span> getAllInterfaces(type, signatureMap);
    <span style="color:#ff79c6">if</span> (interfaces.<span style="color:#50fa7b">length</span> <span style="color:#ff79c6">&gt;</span> 0) {
      <span style="color:#ff79c6">return</span> Proxy.<span style="color:#50fa7b">newProxyInstance</span>(
          type.<span style="color:#50fa7b">getClassLoader</span>(),
          interfaces,
          <span style="color:#ff79c6">new</span> Plugin(target, interceptor, signatureMap));
    }
    <span style="color:#ff79c6">return</span> target;
  }</code></pre></div>
<p>果然发现了<code>Proxy.newProxyInstance</code>，这就是jdk动态代理了。那么这里的target就是interceptorChain.pluginAll(executor)中的executor了。那么对应type.getClassLoader()就是BatchExecutor或SimpleExecutor或ReuseExecutor或CachingExecutor的classloader了，那么在这里又动态创建了一个xxExecutor？继续往下找答案。</p>

<p>在这个wrap方法中，还有两个本地方法的调用一个是getSignatureMap，一个是getAllInterfaces。先看看代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">private static Map<span style="color:#ff79c6">&lt;</span>Class<span style="color:#ff79c6">&lt;?&gt;</span>, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) {
    Intercepts interceptsAnnotation <span style="color:#ff79c6">=</span> interceptor.<span style="color:#50fa7b">getClass</span>().<span style="color:#50fa7b">getAnnotation</span>(Intercepts.<span style="color:#50fa7b">class</span>);
    <span style="color:#6272a4">// issue #251
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> (interceptsAnnotation <span style="color:#ff79c6">==</span> <span style="color:#ff79c6">null</span>) {
      <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> PluginException(<span style="color:#f1fa8c">&#34;No @Intercepts annotation was found in interceptor &#34;</span> <span style="color:#ff79c6">+</span> interceptor.<span style="color:#50fa7b">getClass</span>().<span style="color:#50fa7b">getName</span>());
    }
    Signature[] sigs <span style="color:#ff79c6">=</span> interceptsAnnotation.<span style="color:#50fa7b">value</span>();
    Map<span style="color:#ff79c6">&lt;</span>Class<span style="color:#ff79c6">&lt;?&gt;</span>, Set&lt;Method&gt;&gt; signatureMap <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> HashMap<span style="color:#ff79c6">&lt;&gt;</span>();
    <span style="color:#ff79c6">for</span> (Signature sig <span style="color:#ff79c6">:</span> sigs) {
      Set&lt;Method&gt; methods <span style="color:#ff79c6">=</span> signatureMap.<span style="color:#50fa7b">computeIfAbsent</span>(sig.<span style="color:#50fa7b">type</span>(), k <span style="color:#ff79c6">-&gt;</span> <span style="color:#ff79c6">new</span> HashSet<span style="color:#ff79c6">&lt;&gt;</span>());
      <span style="color:#ff79c6">try</span> {
        Method method <span style="color:#ff79c6">=</span> sig.<span style="color:#50fa7b">type</span>().<span style="color:#50fa7b">getMethod</span>(sig.<span style="color:#50fa7b">method</span>(), sig.<span style="color:#50fa7b">args</span>());
        methods.<span style="color:#50fa7b">add</span>(method);
      } <span style="color:#ff79c6">catch</span> (NoSuchMethodException e) {
        <span style="color:#ff79c6">throw</span> <span style="color:#ff79c6">new</span> PluginException(<span style="color:#f1fa8c">&#34;Could not find method on &#34;</span> <span style="color:#ff79c6">+</span> sig.<span style="color:#50fa7b">type</span>() <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34; named &#34;</span> <span style="color:#ff79c6">+</span> sig.<span style="color:#50fa7b">method</span>() <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;. Cause: &#34;</span> <span style="color:#ff79c6">+</span> e, e);
      }
    }
    <span style="color:#ff79c6">return</span> signatureMap;
  }

  private static Class<span style="color:#ff79c6">&lt;?&gt;</span>[] getAllInterfaces(Class<span style="color:#ff79c6">&lt;?&gt;</span> type, Map<span style="color:#ff79c6">&lt;</span>Class<span style="color:#ff79c6">&lt;?&gt;</span>, Set&lt;Method&gt;&gt; signatureMap) {
    Set<span style="color:#ff79c6">&lt;</span>Class<span style="color:#ff79c6">&lt;?&gt;&gt;</span> interfaces <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> HashSet<span style="color:#ff79c6">&lt;&gt;</span>();
    <span style="color:#ff79c6">while</span> (type <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span>) {
      <span style="color:#ff79c6">for</span> (Class<span style="color:#ff79c6">&lt;?&gt;</span> c <span style="color:#ff79c6">:</span> type.<span style="color:#50fa7b">getInterfaces</span>()) {
        <span style="color:#ff79c6">if</span> (signatureMap.<span style="color:#50fa7b">containsKey</span>(c)) {
          interfaces.<span style="color:#50fa7b">add</span>(c);
        }
      }
      type <span style="color:#ff79c6">=</span> type.<span style="color:#50fa7b">getSuperclass</span>();
    }
    <span style="color:#ff79c6">return</span> interfaces.<span style="color:#50fa7b">toArray</span>(<span style="color:#ff79c6">new</span> Class<span style="color:#ff79c6">&lt;?&gt;</span>[interfaces.<span style="color:#50fa7b">size</span>()]);
  }</code></pre></div>
<p>从代码实现来看，是根据Intercepts的注解来获取对应的Signature和Method信息，果然在PagerInterceptor的class上有这样的一个注解：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Intercepts({@Signature(type <span style="color:#ff79c6">=</span> Executor.<span style="color:#50fa7b">class</span>, method <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;query&#34;</span>, args <span style="color:#ff79c6">=</span> {MappedStatement.<span style="color:#50fa7b">class</span>, Object.<span style="color:#50fa7b">class</span>, RowBounds.<span style="color:#50fa7b">class</span>, ResultHandler.<span style="color:#50fa7b">class</span>})})</code></pre></div>
<p>结合getSignatureMap和getAllInterfaces两个方法，看到目的是为了找到Executor.class的一个query方法，其定义是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">query(MappedStatement ms, Object obj, RowBounds rowBounds, ResultHandler resultHandler);</code></pre></div>
<p>原来越接近真相咯。这个方法在Executor接口中的确有对应的声明，如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">&lt;</span>E&gt; List<span style="color:#ff79c6">&lt;</span>E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException;</code></pre></div>
<p>其在各个Executor也有对应的实现。</p>

<p>解开真相前，再看看Plugin的invoke方法实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    <span style="color:#ff79c6">try</span> {
      Set&lt;Method&gt; methods <span style="color:#ff79c6">=</span> signatureMap.<span style="color:#50fa7b">get</span>(method.<span style="color:#50fa7b">getDeclaringClass</span>());
      <span style="color:#ff79c6">if</span> (methods <span style="color:#ff79c6">!=</span> <span style="color:#ff79c6">null</span> <span style="color:#ff79c6">&amp;&amp;</span> methods.<span style="color:#50fa7b">contains</span>(method)) {
        <span style="color:#ff79c6">return</span> interceptor.<span style="color:#50fa7b">intercept</span>(<span style="color:#ff79c6">new</span> Invocation(target, method, args));
      }
      <span style="color:#ff79c6">return</span> method.<span style="color:#50fa7b">invoke</span>(target, args);
    } <span style="color:#ff79c6">catch</span> (Exception e) {
      <span style="color:#ff79c6">throw</span> ExceptionUtil.<span style="color:#50fa7b">unwrapThrowable</span>(e);
    }
  }</code></pre></div>
<p>那么真相就来咯。路径是这样的：</p>

<ul>
<li>1. openSession时，在DefaultSqlSessionFactory中根据executorType获取对应的Executor；</li>
<li>2. 如果有配置Plugin，那么executor = (Executor) interceptorChain.pluginAll(executor);就会工作，会在创建好对应的Executor后，在使用Plugin的wrap方法wrap一下，其实就是获取其Intercepts注解的Signature，以此获取对应的Method；</li>
<li>3. 根据Executor——target的type和对应的Interfaces，使用jdk的动态代理生成一个新的Executor；</li>
<li>4. 动态生成了新的Executor，那么mapper调用时会触发它的任意方法时，都会触发对应的InnovationHandler也就Plugin的invoke方法；</li>
<li>5. 在invoke方法中，根据对应的有@Intercepts注解的Interceptor的SignatureMap和当前调用的method来判断，将与Intercepts的Signature对应的方法调用进行<strong>拦截</strong>——调用Interceptor的intercept方法。</li>
</ul>

<p>那么在PageInterceptor中，就是Executor调动query(MappedStatement ms, Object obj, RowBounds rowBounds, ResultHandler resultHandler)<strong>前</strong>就会先调用PageInterceptor的intercept方法，从而实现对操作的拦截。</p>

<p>搞定！！！</p>

<p>ref: <a href="https://pagehelper.github.io/docs/interceptor/">https://pagehelper.github.io/docs/interceptor/</a></p>

<p>2019.12.10更新</p>

<p>在拦截相似方法，仅参数列表不一样的interceptor时，如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">&lt;</span>E&gt; List<span style="color:#ff79c6">&lt;</span>E&gt; query(
      MappedStatement ms,
      Object parameter,
      RowBounds rowBounds,
      ResultHandler resultHandler,
      CacheKey cacheKey,
      BoundSql boundSql) throws SQLException;

<span style="color:#ff79c6">&lt;</span>E&gt; List<span style="color:#ff79c6">&lt;</span>E&gt; query(
      MappedStatement ms,
      Object parameter,
      RowBounds rowBounds,
      ResultHandler resultHandler) throws SQLException;</code></pre></div>
<p>需要注意插件配置顺序：按照参数数量，倒序在MyBatis-config.xml中配置，这样能确保，每一个interceptor都能正常工作。因为对应不同的参数的方法，在拦截时，对应的调用顺序会被打乱，导致部分拦截无法工作。比如query拦截，直接调用了query的6参方法，那么对4参的方法拦截就不能生效——因为跳过了4参方法的调用。所以按照参数数量倒序配置，执行时会按照参数数量从少到多的顺序执行，保证每个interceptor都能正常工作。</p>


</article>

<script src="https://utteranc.es/client.js"
    repo="qicz/ThoughtsHUB"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>

<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://izcqi.com/posts/2019/12/08/generate-gitigore-file/"><i class="fa fa-chevron-circle-left"></i> 快速的生成你需要的.gitignore文件</a>
        </li>
        
        
        <li>
            <a href="https://izcqi.com/posts/2019/12/20/springboot-fatjar-vs-thinjar/">SpringBoot FatJar vs ThinJar&amp;SpringBoot Thin Planing <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    




</main>
    <footer>
        <h6>&copy; 2012 - 2020 Qicz 
            - Qicz&#39;s Thoughts HUB (<a href="https://izcqi.com/"> https://izcqi.com</a>)
            | Theme <a href="https://github.com/qicz/qicz-hugo-theme">qicz-theme</a>
            | This site USES <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></h6>
    </footer>
</div>

<script async src="https://izcqi.com/js/busuanzi.pure.mini.js"></script>

</body>

</html>

