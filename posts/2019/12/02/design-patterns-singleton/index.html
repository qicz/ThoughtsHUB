<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.59.1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <title>软件设计模式之单例模式 | Qicz&#39;s Thoughts HUB</title>
  <meta property="og:title" content="软件设计模式之单例模式 - Qicz&#39;s Thoughts HUB">
  <meta property="og:type" content="article">
      
  <meta property="article:published_time" content="2019-12-02T14:36:39&#43;08:00">
      
      
  <meta property="article:modified_time" content="2019-12-02T14:36:39&#43;08:00">
      
  <meta name="Keywords" content="Qicz,Jobsz,RD,technology,tech,learning,设计模式,分布式,架构设计,P6,P7,软件设计,数据库,大数据,MySQL,Zookeeper,MongoDB,redis,dubbo,ServiceMesh,SOFAMesh,Serverless,hugo,Java,Mybatis,Spring,Spring Boot,Spring Cloud,istio">
  <meta name="description" content="软件设计模式之单例模式">
      
  <meta name="author" content="Qicz">
  <meta property="og:url" content="https://izcqi.com/posts/2019/12/02/design-patterns-singleton/">
  
  <link rel="shortcut icon" href="https://izcqi.com/favicon.png" />
  

  <meta property="og:title" content="软件设计模式之单例模式" />
<meta property="og:description" content="单例模式是软件设计中非常常见的模式，但真正用好也用对的好像还有很多路要走。一起来研究一下。
单例，最最起码得有这些吧
 私有的构造方案 一个 static 的实例 一个 static 的外部访问入口  具体代码应该是这样的(懒汉模式)
public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (null == instance) { instance = new Singleton(); } return instance; } } 当然了，看着好像是那么回事，完成了以上操作，我们来测试一下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://izcqi.com/posts/2019/12/02/design-patterns-singleton/" />
<meta property="article:published_time" content="2019-12-02T14:36:39+08:00" />
<meta property="article:modified_time" content="2019-12-02T14:36:39+08:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="软件设计模式之单例模式"/>
<meta name="twitter:description" content="单例模式是软件设计中非常常见的模式，但真正用好也用对的好像还有很多路要走。一起来研究一下。
单例，最最起码得有这些吧
 私有的构造方案 一个 static 的实例 一个 static 的外部访问入口  具体代码应该是这样的(懒汉模式)
public class Singleton { private static Singleton instance = null; private Singleton(){} public static Singleton getInstance() { if (null == instance) { instance = new Singleton(); } return instance; } } 当然了，看着好像是那么回事，完成了以上操作，我们来测试一下"/>
<meta name="generator" content="Hugo 0.59.1" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />  
  <link rel="stylesheet" href="https://izcqi.com/css/free.min.css?livereload=1574867372890" media="all">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://izcqi.com/css/styles.css" />
  
  <link href="https://izcqi.com/css/monokai.min.css" rel="stylesheet">
  </head>

<body>
  <div id="container">
    <header-container>
    <header>
      <h1>
        <a href="https://izcqi.com/">Qicz&rsquo;s Thoughts HUB</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="mailto:zcq#zhucongqi.cn" title="Email me" target="_blank">
               <i class="fas fa-envelope fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://www.facebook.com/qiczhu" title="Facebook" target="_blank">
               <i class="fab fa-facebook fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://github.com/qicz" title="GitHub" target="_blank">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://reddit.com/u/Qiczhu" title="Reddit" target="_blank">
               <i class="fab fa-reddit-alien fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://weibo.com/powerlinux" title="Weibo" target="_blank">
               <i class="fab fa-weibo fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://douban.com/people/podevor" title="Douban" target="_blank">
               <i class="fab fa-spotify fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>The creative and technical writing.</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://izcqi.com/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>
  </header-container>
    <main>




<article>

    <h1>软件设计模式之单例模式</h1>

    
        <aside>
    
    <span class="fa fa-calendar"><time class="post-date" datetime="2019-12-02T14:36:39&#43;08:00"> Dec 2, 2019 14:36</time>
    &nbsp; | &nbsp; 
    
    <span class="fa fa-book">
        <em class="categories">
            
                
                <a href="https://izcqi.com/categories/design-patterns">design-patterns</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
     
    <span class="fa fa-tags">
        <em class="tags">
            
                
                <a href="https://izcqi.com/tags/singleton">#singleton</a>
            
                , 
                <a href="https://izcqi.com/tags/design-patterns">#design-patterns</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
    <span class="fa fa-plane"><em> 3 minutes read</em> </span>
</aside>


    

    <p>单例模式是软件设计中非常常见的模式，但真正用好也用对的好像还有很多路要走。一起来研究一下。</p>

<p>单例，最最起码得有这些吧</p>

<ul>
<li>私有的构造方案</li>
<li>一个 static 的实例</li>
<li>一个 static 的外部访问入口</li>
</ul>

<p>具体代码应该是这样的(懒汉模式)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class Singleton {

    private static Singleton instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;

    private Singleton(){}

    public static Singleton getInstance() {
        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> instance) {
            instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Singleton();
        }
        <span style="color:#ff79c6">return</span> instance;
    }
}</code></pre></div>
<p>当然了，看着好像是那么回事，完成了以上操作，我们来测试一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class SingletonTest {

    public static void main(String[] args) {
        <span style="color:#ff79c6">for</span> (int i <span style="color:#ff79c6">=</span> 0; i <span style="color:#ff79c6">&lt;</span> 3; i<span style="color:#ff79c6">++</span>) {
            <span style="color:#6272a4">//test1
</span><span style="color:#6272a4"></span>            Singleton singleton <span style="color:#ff79c6">=</span> Singleton.<span style="color:#50fa7b">getInstance</span>();
            System.<span style="color:#50fa7b">out</span>.<span style="color:#50fa7b">println</span>(<span style="color:#f1fa8c">&#34;running at thread&#34;</span> <span style="color:#ff79c6">+</span> Thread.<span style="color:#50fa7b">currentThread</span>().<span style="color:#50fa7b">getName</span>() <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;&gt;&gt;&#34;</span> <span style="color:#ff79c6">+</span> singleton);
        }
    }
}</code></pre></div>
<p>输出（每次运行输出是不一样的）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">running at threadmain&gt;&gt;cn.zhucongqi.singleton.Singleton@49476842
running at threadmain&gt;&gt;cn.zhucongqi.singleton.Singleton@49476842
running at threadmain&gt;&gt;cn.zhucongqi.singleton.Singleton@49476842</code></pre></div>
<p>单例完成了！？</p>

<p>我们在多线程下测试一下，改造一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class SingletonTest {

    public static void main(String[] args) {
<span style="color:#6272a4">//        for (int i = 0; i &lt; 3; i++) {
</span><span style="color:#6272a4">//            //test1
</span><span style="color:#6272a4">//            Singleton singleton = Singleton.getInstance();
</span><span style="color:#6272a4">//            System.out.println(&#34;running at thread&#34; + Thread.currentThread().getName() + &#34;&gt;&gt;&#34; + singleton);
</span><span style="color:#6272a4">//        }
</span><span style="color:#6272a4"></span>

        <span style="color:#6272a4">//test2
</span><span style="color:#6272a4"></span>        Runnable r <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Runnable() {
            @Override
            public void run() {
                Singleton singleton <span style="color:#ff79c6">=</span> Singleton.<span style="color:#50fa7b">getInstance</span>();
                System.<span style="color:#50fa7b">out</span>.<span style="color:#50fa7b">println</span>(<span style="color:#f1fa8c">&#34;running at thread&#34;</span> <span style="color:#ff79c6">+</span> Thread.<span style="color:#50fa7b">currentThread</span>().<span style="color:#50fa7b">getName</span>() <span style="color:#ff79c6">+</span> <span style="color:#f1fa8c">&#34;&gt;&gt;&#34;</span> <span style="color:#ff79c6">+</span> singleton);
            }
        };
        <span style="color:#ff79c6">new</span> Thread(r).<span style="color:#50fa7b">start</span>();
        <span style="color:#ff79c6">new</span> Thread(r).<span style="color:#50fa7b">start</span>();
        <span style="color:#ff79c6">new</span> Thread(r).<span style="color:#50fa7b">start</span>();
        <span style="color:#ff79c6">new</span> Thread(r).<span style="color:#50fa7b">start</span>();
        <span style="color:#ff79c6">new</span> Thread(r).<span style="color:#50fa7b">start</span>();
    }
}</code></pre></div>
<p>输出（每次运行输出是不一样的）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">running at threadThread-2&gt;&gt;cn.zhucongqi.singleton.Singleton@a1a1c96
running at threadThread-5&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-4&gt;&gt;cn.zhucongqi.singleton.Singleton@a1a1c96
running at threadThread-3&gt;&gt;cn.zhucongqi.singleton.Singleton@a1a1c96
running at threadThread-0&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-1&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc</code></pre></div>
<p>出现问题了！！！怎么在多线程下出现了不同实例了？？？是不是我们的设计有问题呢？我们在图示位置打个断点，按照 Thread 来处理</p>

<p><img src="https://izcqi.com/images/singleton-point.png" alt="" /></p>

<p>然后 Debug 一下
<img src="https://izcqi.com/images/singleton-breakpoint-running.png" alt="" /></p>

<p>我们先来看看 Thread0 的情况
<img src="https://izcqi.com/images/singleton-breakpoint-t0-running.png" alt="" />
<img src="https://izcqi.com/images/singleton-breakpoint-t0-over.png" alt="" /></p>

<p>看到此时<code>instance</code>为{Singleton@475}。我们换到 Thread1 再看看
<img src="https://izcqi.com/images/singleton-breakpoint-t1-running.png" alt="" />
看到此时<code>instance</code>也是{Singleton@475}。往下走
<img src="https://izcqi.com/images/singleton-breakpoint-t1-over.png" alt="" /></p>

<p>额等等，怎么<code>instance</code>变成<code>{Singleton@476}</code>了，被覆盖咯？？？
看来我们的设计有问题哦！</p>

<p>怎么改造呢？</p>

<p>从 Debug 来看，是<code>getInstance()</code>时出现了线程安全问题，我们用<code>synchronized</code>是不是可以解决问题呢？我们再改造一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class Singleton {

    private static Singleton instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;

    private Singleton(){}

    public synchronized static Singleton getInstance() {
        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> instance) {
            instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Singleton();
        }
        <span style="color:#ff79c6">return</span> instance;
    }
}</code></pre></div>
<p>再 Debug 一下。
<img src="https://izcqi.com/images/singleton-breakpoint-monitor.png" alt="" />
看到就一个 Thread 是 running 的，其他的是 Monitor 的，是不是可以了。我们往下继续走。
<img src="https://izcqi.com/images/singleton-breakpoint-monitor-t0-over.png" alt="" />
看到，Thread0 走出来之后，Thread4 才进入到 Running 状态。也就是加入<code>synchronized</code>把整个class都锁住了。目的到底，但是性能不好。我们再改造一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class Singleton {

    private static Singleton instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;

    private Singleton(){}

    public static Singleton getInstance() {
        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> instance) {
            <span style="color:#8be9fd;font-style:italic">synchronized</span>(Singleton.<span style="color:#50fa7b">class</span>) {
                instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Singleton();
            }
        }
        <span style="color:#ff79c6">return</span> instance;
    }
}</code></pre></div>
<p>再Debug 看看
<img src="https://izcqi.com/images/singleton-breakpoint-running-2.png" alt="" />
现在所有 Thread 都是 Running 的了。我们继续走，先看看 Thread0
<img src="https://izcqi.com/images/singleton-breakpoint-t0-running-2.png" alt="" />
再看看 Thread3
<img src="https://izcqi.com/images/singleton-breakpoint-t3-running.png" alt="" />
看样子又要被覆盖咯！！！看来还是不行哦！是不是我们再加一把锁哦？！</p>

<p>我们再改造一下</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">public class Singleton {

    private static Singleton instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;

    private Singleton(){}

    public static Singleton getInstance() {
        <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> instance) {
            <span style="color:#8be9fd;font-style:italic">synchronized</span>(Singleton.<span style="color:#50fa7b">class</span>) {
                <span style="color:#ff79c6">if</span> (<span style="color:#ff79c6">null</span> <span style="color:#ff79c6">==</span> instance) {
                    instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Singleton();
                }
            }
        }
        <span style="color:#ff79c6">return</span> instance;
    }
}</code></pre></div>
<p>这次我们先 Run 一下看看结果，输出</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">running at threadThread-2&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-0&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-1&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-3&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc
running at threadThread-4&gt;&gt;cn.zhucongqi.singleton.Singleton@b0545bc</code></pre></div>
<p>结果对咯！为什么呢？</p>

<p>其实，刚才的效果和不断的改造，我们把最初的<code>Singleton</code>改造成了<strong>DoubleCheck</strong> 的懒汉式Singleton了。</p>

<p>当然了，上面这种方式只是一种方式罢了。下面直接上其他的方式Code。</p>

<blockquote>
<p>2020.2.20更新</p>

<p>在Doublecheck的第一次check的时候，<strong>代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</strong>主要原因是<strong>重排序</strong>，<strong>所以只需要做一点小的修改（把instance声明为volatile型），就可以实现线程安全的延迟初始化。</strong>因为被volatile关键字修饰的变量是被禁止重排序的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">&gt;</span> private static volatile Singleton instance <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span>;
<span style="color:#ff79c6">&gt;</span> ```

## EnumSingleton 枚举方式实现的单例</code></pre></div>
<p>java
// Enum Singleton
public enum EnumSingleton {</p>
</blockquote>

<pre><code>INSTANCE;

public static EnumSingleton getInstance() {
    return INSTANCE;
}
</code></pre>

<p>}</p>

<pre><code>
## InnerClassSingleton 内部类方式实现的单例
</code></pre>

<p>java
// Inner class Singleton
public class InnerSingleton {</p>

<pre><code>private InnerSingleton(){
    if (null != InnerHolder.INSTANCE) {
        throw new RuntimeException(&quot;Just only one Instance can be create!&quot;);
    }
}

//Serializable
private Object readResolve() {
    return InnerHolder.INSTANCE;
}

public static InnerSingleton getInstance() {
    return InnerHolder.INSTANCE;
}

private static class InnerHolder {
    private static final InnerSingleton INSTANCE = new InnerSingleton();
}
</code></pre>

<p>}</p>

<pre><code>
## 特别说明

- 为了避免序列化出现的 Singleton 实例不唯一的情况，覆盖 Object 的readResolve方法。
</code></pre>

<p>java
private Object readResolve() {
        return InnerHolder.INSTANCE;
    }</p>

<pre><code>
- 为了避免，通过反射错误的使用 Singleton，在构造中做再处理
</code></pre>

<p>java
 private InnerSingleton(){
        if (null != InnerHolder.INSTANCE) {
            throw new RuntimeException(&ldquo;Just only one Instance can be create!&rdquo;);
        }
}
```</p>


</article>

<script src="https://utteranc.es/client.js"
    repo="qicz/ThoughtsHUB"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>

<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://izcqi.com/posts/2019/11/27/barrel-and-strengths-avoid-weaknesses/"><i class="fa fa-chevron-circle-left"></i> 木桶与扬长避短</a>
        </li>
        
        
        <li>
            <a href="https://izcqi.com/posts/2019/12/02/distributed-platform-design-principles/">分布式系统/高并发系统设计原则 <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
    




</main>
    <footer>
        <h6>&copy; 2012 - 2020 Qicz 
            - Qicz&#39;s Thoughts HUB (<a href="https://izcqi.com/"> https://izcqi.com</a>)
            | Theme <a href="https://github.com/qicz/qicz-hugo-theme">qicz-theme</a>
            | This site USES <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></h6>
    </footer>
</div>

<script async src="https://izcqi.com/js/busuanzi.pure.mini.js"></script>

</body>

</html>

