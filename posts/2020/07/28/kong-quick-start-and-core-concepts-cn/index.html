<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
  <meta name="generator" content="Hugo 0.59.1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <title>Kong Quick Start &amp; Core Concepts (cn)  | Qicz&#39;s Thoughts HUB</title>
  <meta property="og:title" content="Kong Quick Start &amp; Core Concepts (cn)  - Qicz&#39;s Thoughts HUB">
  <meta property="og:type" content="article">
      
  <meta property="article:published_time" content="2020-07-28T22:23:39&#43;08:00">
      
      
  <meta property="article:modified_time" content="2020-07-28T22:23:39&#43;08:00">
      
  <meta name="Keywords" content="Qicz,Jobsz,RD,technology,tech,learning,设计模式,分布式,架构设计,P6,P7,软件设计,数据库,大数据,MySQL,Zookeeper,MongoDB,redis,dubbo,ServiceMesh,SOFAMesh,Serverless,hugo,Java,Mybatis,Spring,Spring Boot,Spring Cloud,istio">
  <meta name="description" content="Kong Quick Start &amp; Core Concepts (cn) ">
      
  <meta name="author" content="Qicz">
  <meta property="og:url" content="https://izcqi.com/posts/2020/07/28/kong-quick-start-and-core-concepts-cn/">
  
  <link rel="shortcut icon" href="https://izcqi.com/favicon.png" />
  

  <meta property="og:title" content="Kong Quick Start &amp; Core Concepts (cn) " />
<meta property="og:description" content="从技术的角度来说，Kong是什么（因为Kong也有金刚意思）? (https://docs.konghq.com/2.1.x/getting-started/introduction/) Kong是一个运行在Nginx中的基于Lua - Nginx模块实现的Lua应用程序。Kong与OpenResty一起发布的，以此替代在Nginx中还需编译Lua - Nginx模块，OpenResty已经包含了lua- Nginx模块。OpenResty不是Nginx的一个分支，而是一组扩展其功能的模块。
Kong是一个基于云的、快速的、可伸缩的分布式微服务抽象层(也称为API网关或API中间件)。2015年作为开源项目发布，其核心价值是高性能和可扩展性。
为何选择Kong？ 如果您正在为web、移动或物联网构建服务，那们您可能还需要通用功能来运行您的实际软件。Kong可以充当微服务请求的网关(或侧卡)，同时通过插件提供负载平衡、日志记录、身份验证、速率限制、转换等功能。
Kong的构建遵循以下主要原则：
 高性能：亚毫秒级处理延迟，可支持关键任务用例和高吞吐量。 可扩展性：带有可插拔的体系结构，可通过Kong的Plugin SDK扩展Lua或GoLang中的Kong。 可移植性：要在每个平台，每个云上运行，并通过我们的现代Ingress Controller本地支持Kubernetes。  Features  Cloud-Native：与平台无关，Kong可以在任何平台上运行-从裸机到容器-并且可以在本机上的每个云上运行。 Kubernetes-Native：使用官方的Ingress Controller通过本地Kubernetes CRD声明性地配置Kong，以路由和连接所有L4 &#43; L7通信。 动态负载平衡：在多个上游服务之间平衡流量。 基于哈希的负载平衡：具有一致的哈希/粘性会话的负载平衡。 断路器：智能跟踪不健康的上游服务。 运行状况检查：主动和被动监视上游服务。 服务发现：在第三方DNS解析器（例如Consul）中解析SRV记录。 无服务器：直接从Kong调用和保护AWS Lambda或OpenWhisk功能。 WebSockets：通过WebSockets与您的上游服务进行通信。 gRPC：与gRPC服务进行通信，并通过日志记录和可观察性插件观察流量 OAuth2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://izcqi.com/posts/2020/07/28/kong-quick-start-and-core-concepts-cn/" />
<meta property="article:published_time" content="2020-07-28T22:23:39+08:00" />
<meta property="article:modified_time" content="2020-07-28T22:23:39+08:00" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kong Quick Start &amp; Core Concepts (cn) "/>
<meta name="twitter:description" content="从技术的角度来说，Kong是什么（因为Kong也有金刚意思）? (https://docs.konghq.com/2.1.x/getting-started/introduction/) Kong是一个运行在Nginx中的基于Lua - Nginx模块实现的Lua应用程序。Kong与OpenResty一起发布的，以此替代在Nginx中还需编译Lua - Nginx模块，OpenResty已经包含了lua- Nginx模块。OpenResty不是Nginx的一个分支，而是一组扩展其功能的模块。
Kong是一个基于云的、快速的、可伸缩的分布式微服务抽象层(也称为API网关或API中间件)。2015年作为开源项目发布，其核心价值是高性能和可扩展性。
为何选择Kong？ 如果您正在为web、移动或物联网构建服务，那们您可能还需要通用功能来运行您的实际软件。Kong可以充当微服务请求的网关(或侧卡)，同时通过插件提供负载平衡、日志记录、身份验证、速率限制、转换等功能。
Kong的构建遵循以下主要原则：
 高性能：亚毫秒级处理延迟，可支持关键任务用例和高吞吐量。 可扩展性：带有可插拔的体系结构，可通过Kong的Plugin SDK扩展Lua或GoLang中的Kong。 可移植性：要在每个平台，每个云上运行，并通过我们的现代Ingress Controller本地支持Kubernetes。  Features  Cloud-Native：与平台无关，Kong可以在任何平台上运行-从裸机到容器-并且可以在本机上的每个云上运行。 Kubernetes-Native：使用官方的Ingress Controller通过本地Kubernetes CRD声明性地配置Kong，以路由和连接所有L4 &#43; L7通信。 动态负载平衡：在多个上游服务之间平衡流量。 基于哈希的负载平衡：具有一致的哈希/粘性会话的负载平衡。 断路器：智能跟踪不健康的上游服务。 运行状况检查：主动和被动监视上游服务。 服务发现：在第三方DNS解析器（例如Consul）中解析SRV记录。 无服务器：直接从Kong调用和保护AWS Lambda或OpenWhisk功能。 WebSockets：通过WebSockets与您的上游服务进行通信。 gRPC：与gRPC服务进行通信，并通过日志记录和可观察性插件观察流量 OAuth2."/>
<meta name="generator" content="Hugo 0.59.1" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" />  
  <link rel="stylesheet" href="https://izcqi.com/css/free.min.css?livereload=1574867372890" media="all">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  <link rel="stylesheet" type="text/css" href="https://izcqi.com/css/styles.css" />
  
  <link href="https://izcqi.com/css/monokai.min.css" rel="stylesheet">
  </head>

<body>
  <div id="container">
    <header-container>
    <header>
      <h1>
        <a href="https://izcqi.com/">Qicz&rsquo;s Thoughts HUB</a>
      </h1>

      <ul id="social-media">
             <li>
               <a href="mailto:zcq#zhucongqi.cn" title="Email me" target="_blank">
               <i class="fas fa-envelope fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://github.com/qicz" title="GitHub" target="_blank">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://weibo.com/powerlinux" title="Weibo" target="_blank">
               <i class="fab fa-weibo fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://douban.com/people/podevor" title="Douban" target="_blank">
               <i class="fab fa-spotify fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>The creative and technical writing. <br> Do more, challenge more, know more, be more.</em></p>
      
    </header>

    
<nav>
    <ul>
        
        <li>
            <a class="" href="https://izcqi.com/posts/">
                <i class="fa-li fa  fa-lg"></i><span>Posts</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/categories/">
                <i class="fa-li fa  fa-lg"></i><span>Categories</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/tags/">
                <i class="fa-li fa  fa-lg"></i><span>Tags</span>
            </a>
        </li>
        
        <li>
            <a class="" href="https://izcqi.com/about/">
                <i class="fa-li fa  fa-lg"></i><span>About</span>
            </a>
        </li>
        
    </ul>
</nav>
  </header-container>
    <main>




<article>

    <h1>Kong Quick Start &amp; Core Concepts (cn) </h1>

    
        <aside>
    
    <span class="fa fa-calendar"><time class="post-date" datetime="2020-07-28T22:23:39&#43;08:00"> Jul 28, 2020 22:23</time>
    &nbsp; | &nbsp; 
    
    <span class="fa fa-book">
        <em class="categories">
            
                
                <a href="https://izcqi.com/categories/gateway">gateway</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
     
    <span class="fa fa-tags">
        <em class="tags">
            
                
                <a href="https://izcqi.com/tags/kong">#kong</a>
            
        </em>
    </span>
    
    &nbsp; | &nbsp; 
    <span class="fa fa-plane"><em> 11 minutes read</em> </span>
</aside>


    

    

<h3 id="从技术的角度来说-kong是什么-因为kong也有金刚意思-https-docs-konghq-com-2-1-x-getting-started-introduction">从技术的角度来说，Kong是什么（因为Kong也有金刚意思）? (<a href="https://docs.konghq.com/2.1.x/getting-started/introduction/">https://docs.konghq.com/2.1.x/getting-started/introduction/</a>)</h3>

<p>Kong是一个运行在Nginx中的基于Lua - Nginx模块实现的Lua应用程序。Kong与OpenResty一起发布的，以此替代在Nginx中还需编译Lua - Nginx模块，OpenResty已经包含了lua- Nginx模块。OpenResty不是Nginx的一个分支，而是一组扩展其功能的模块。</p>

<p>Kong是一个基于云的、快速的、可伸缩的分布式微服务抽象层(也称为API网关或API中间件)。2015年作为开源项目发布，其核心价值是高性能和可扩展性。</p>

<h4 id="为何选择kong">为何选择Kong？</h4>

<p>如果您正在为web、移动或物联网构建服务，那们您可能还需要通用功能来运行您的实际软件。Kong可以充当微服务请求的网关(或侧卡)，同时通过插件提供负载平衡、日志记录、身份验证、速率限制、转换等功能。</p>

<p><img src="https://izcqi.com/images/image-20200728111142106.png#mid" alt="Different architecture compare" /></p>

<p>Kong的构建遵循以下主要原则：</p>

<ul>
<li><strong>高性能</strong>：亚毫秒级处理延迟，可支持关键任务用例和高吞吐量。</li>
<li><strong>可扩展性</strong>：带有可插拔的体系结构，可通过Kong的Plugin SDK扩展Lua或GoLang中的Kong。</li>
<li><strong>可移植性</strong>：要在每个平台，每个云上运行，并通过我们的现代Ingress Controller本地支持Kubernetes。</li>
</ul>

<h4 id="features">Features</h4>

<ul>
<li><strong>Cloud-Native</strong>：与平台无关，Kong可以在任何平台上运行-从裸机到容器-并且可以在本机上的每个云上运行。</li>
<li><strong>Kubernetes-Native</strong>：使用官方的Ingress Controller通过本地Kubernetes CRD声明性地配置Kong，以路由和连接所有L4 + L7通信。</li>
<li><strong>动态负载平衡</strong>：在多个上游服务之间平衡流量。</li>
<li><strong>基于哈希的负载平衡</strong>：具有一致的哈希/粘性会话的负载平衡。</li>
<li><strong>断路器</strong>：智能跟踪不健康的上游服务。</li>
<li><strong>运行状况检查：</strong>主动和被动监视上游服务。</li>
<li><strong>服务发现</strong>：在第三方DNS解析器（例如Consul）中解析SRV记录。</li>
<li><strong>无服务器</strong>：直接从Kong调用和保护AWS Lambda或OpenWhisk功能。</li>
<li><strong>WebSockets</strong>：通过WebSockets与您的上游服务进行通信。</li>
<li><strong>gRPC</strong>：与gRPC服务进行通信，并通过日志记录和可观察性插件观察流量</li>
<li><strong>OAuth2.0</strong>：轻松将OAuth2.0身份验证添加到您的API。</li>
<li><strong>记录</strong>：通过HTTP，TCP，UDP或磁盘<strong>记录</strong>对系统的请求和响应。</li>
<li><strong>安全性</strong>：ACL，僵尸程序检测，允许/拒绝IP等&hellip;</li>
<li><strong>Syslog</strong>:  系统日志记录.</li>
<li><strong>SSL</strong>：为基础服务或API设置特定的SSL证书。</li>
<li><strong>监视</strong>：实时监视提供关键的负载和性能服务器指标。</li>
<li><strong>转发代理</strong>：使Kong连接到透明的中介HTTP代理。</li>
<li><strong>认证</strong>：HMAC，JWT，Basic等。</li>
<li><strong>速率限制</strong>：基于许多变量的阻止和限制请求。</li>
<li><strong>转换</strong>：添加，删除或处理HTTP请求和响应。</li>
<li><strong>缓存</strong>：在代理层缓存并提供响应。</li>
<li><strong>CLI</strong>：<strong>从命令行</strong>控制Kong群集。</li>
<li><strong>REST API</strong>：Kong可以使用其RESTful API进行操作，以实现最大的灵活性。</li>
<li><strong>地理复制</strong>：跨不同区域的配置始终是最新的。</li>
<li><strong>故障检测和恢复</strong>：如果您的Cassandra节点之一发生<strong>故障，则</strong> Kong不会受到影响。</li>
<li><strong>集群</strong>：所有Kong节点自动加入集群，并在各个节点之间更新其配置。</li>
<li><strong>可伸缩性</strong>：Kong本质上分布，只需添加节点即可水平<strong>扩展</strong>。</li>
<li><strong>性能</strong>：Kong通过扩展和使用NGINX作为核心轻松处理负载。</li>
<li><strong>插件</strong>：可扩展的体系结构，用于向Kong和API添加功能。</li>
</ul>

<p><img src="https://izcqi.com/images/image-20200727154809091.png#mid" alt="Kong layer" /></p>

<h3 id="concepts">Concepts</h3>

<ul>
<li>Services</li>
<li>Routes</li>
<li>Upstreams</li>
<li>Targets</li>
<li>Tags</li>
<li>Consumers</li>
<li>Plugins</li>
<li>Others

<ul>
<li>Certificate Object</li>
<li>CA Certificate Object</li>
<li>SNI Object</li>
</ul></li>
</ul>

<h3 id="plugins">Plugins</h3>

<h4 id="proxy-cache-plugin-https-docs-konghq-com-hub-kong-inc-proxy-cache">proxy-cache plugin (<a href="https://docs.konghq.com/hub/kong-inc/proxy-cache/">https://docs.konghq.com/hub/kong-inc/proxy-cache/</a>)</h4>

<ul>
<li>主要参数

<ul>
<li><code>config.content_type</code> 缓存某指定的<code>content_type</code>类型的数据</li>
<li><code>config.cache_ttl</code> 缓存存活时间，默认 <code>300秒</code></li>
<li><code>config.strategy</code>  缓存策略，社区版本只支持<code>memory</code></li>
<li><code>config.request_method</code>  默认取值 <code>[&quot;GET&quot;,&quot;HEAD&quot;]</code></li>
<li><code>config.response_code</code>  默认取值 <code>200, 301, 404</code></li>
</ul></li>
<li>缓存状态

<ul>
<li><code>Miss</code>: 在缓存中没有找到数据，向上游服务请求以获取数据，并缓存返回数据。</li>
<li><code>Hit</code>: 请求中缓存中命中数据。</li>
<li><code>Refresh</code>: 由于在Cache-Control行为或达到其硬编码cache_ttl阈值，因此在缓存中找到了资源，但无法满足请求。</li>
<li><code>Bypass</code>: 根据插件配置，缓存无法满足该请求。</li>
</ul></li>
</ul>

<h4 id="rote-limiting-plugin-https-docs-konghq-com-hub-kong-inc-rate-limiting">Rote Limiting plugin (<a href="https://docs.konghq.com/hub/kong-inc/rate-limiting/">https://docs.konghq.com/hub/kong-inc/rate-limiting/</a>)</h4>

<ul>
<li><p>主要参数</p>

<ul>
<li><code>config.policy</code>用于检索和增加限制的速率限制策略。可用值为<code>local</code>（计数器将存储在本地内存中的节点上），<code>cluster</code>（计数器存储在数据存储区中并在节点上共享）和<code>redis</code>（计数器存储在Redis服务器上并在节点之间共享）。在无DB模式下，必须至少指定<code>local</code>或之一<code>redis</code>。请参阅<a href="https://docs.konghq.com/hub/kong-inc/rate-limiting/#implementation-considerations">实施注意事项，</a>以了解有关应使用哪种策略的详细信息。</li>
</ul></li>
</ul>

<blockquote>
<p><code>config.policy=redis</code></p>

<p>使用 <code>config.redis*</code> =&gt;<code>redis_host|redis_password|redis_database|redis_timeout</code></p>
</blockquote>

<ul>
<li><code>config.</code> <code>second|minute|hour|day|month|year</code> 配置对应单位时间内的请求限制数</li>
</ul>

<h4 id="key-auth-plugin-https-docs-konghq-com-hub-kong-inc-key-auth">Key Auth plugin (<a href="https://docs.konghq.com/hub/kong-inc/key-auth/">https://docs.konghq.com/hub/kong-inc/key-auth/</a>)</h4>

<ul>
<li>主要参数

<ul>
<li><code>config.key_names</code> 默认名称 <code>apikey</code>，可以配置修改</li>
</ul></li>
<li>使用步骤

<ul>
<li>创建 a Consumer</li>
<li>创建一个  Key</li>
<li>然后使用 Key</li>
</ul></li>
</ul>

<h4 id="load-balancing-plugin-https-docs-konghq-com-getting-started-guide-2-1-x-load-balancing">Load Balancing plugin (<a href="https://docs.konghq.com/getting-started-guide/2.1.x/load-balancing/">https://docs.konghq.com/getting-started-guide/2.1.x/load-balancing/</a>)</h4>

<ul>
<li>Concepts

<ul>
<li>Upstreams</li>
<li>Targets</li>
</ul></li>
</ul>

<h3 id="自定义nginx模板并嵌入kong-https-docs-konghq-com-2-1-x-configuration">自定义Nginx模板并嵌入Kong (<a href="https://docs.konghq.com/2.1.x/configuration/">https://docs.konghq.com/2.1.x/configuration/</a>)</h3>

<p><code>$ kong start -c kong.conf --nginx-conf custom_nginx.template</code></p>

<h3 id="术语">术语</h3>

<ul>
<li><code>client</code>:  向Kong的代理接口发起请求的下游客户端。</li>
<li><code>upstream service</code>:  Kong代理的上游服务，也就是具体的业务服务。</li>
<li><code>Service</code>:  Kong对上游服务在Kong内部的抽象。</li>
<li><code>Route</code>:  client进入Kong的入口，定义对应的匹配规则，并将匹配的路由到对应的上游服务。</li>
<li><code>Plugin</code>:  Kong“插件”，它们是在代理生命周期中运行的业务逻辑。可以通过Admin API配置插件-全局（所有传入流量）或特定的路由和服务上。</li>
</ul>

<h3 id="ports">Ports</h3>

<ul>
<li>proxy：默认http端口<code>8000</code>，https端口<code>8443</code> ，下游的服务经过此接口进入Kong。</li>
<li>admin：默认http端口<code>8001</code>，https端口<code>8444</code> ，对Kong的动态配置的RestfulApi</li>
</ul>

<blockquote>
<p>均可通过 <code>/etc/kong/kong.conf</code>进行修改。</p>
</blockquote>

<h3 id="路由及其匹配">路由及其匹配</h3>

<p>Kong支持HTTP / HTTPS，TCL / TLS和GRPC / GRPCS协议的本机代理；如前所述，这些协议中的每一个都接受一组不同的路由属性：</p>

<ul>
<li><code>http</code>: <code>methods</code>, <code>hosts</code>, <code>headers</code>, <code>paths</code> (and <code>snis</code>, if <code>https</code>)</li>
<li><code>tcp</code>: <code>sources</code>, <code>destinations</code> (and <code>snis</code>, if <code>tls</code>)</li>
<li><code>grpc</code>: <code>hosts</code>, <code>headers</code>, <code>paths</code> (and <code>snis</code>, if <code>grpcs</code>)</li>
</ul>

<blockquote>
<p>请注意，这三个字段都是<strong>可选</strong>字段，但必须至少指定<strong>其中一个</strong>。</p>
</blockquote>

<p>一个可以被匹配的请求，需满足:</p>

<ul>
<li>该请求<strong>必须</strong>包含<strong>所有</strong>已配置的字段。</li>
<li>请求中字段的值<strong>必须</strong>至少与配置的值之一匹配（虽然字段配置接受一个或多个值，但请求仅需要将其中一个值视为匹配项）。</li>
</ul>

<p>举例说明：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;hosts&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;example.com&#34;</span>, <span style="color:#f1fa8c">&#34;foo-service.com&#34;</span>],
    <span style="color:#f1fa8c">&#34;paths&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;/foo&#34;</span>, <span style="color:#f1fa8c">&#34;/bar&#34;</span>],
    <span style="color:#f1fa8c">&#34;methods&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;GET&#34;</span>]
}</code></pre></div>
<p>与此路由匹配的一些可能请求如下所示:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /foo <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /bar <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> foo-service.com</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /foo/hello/world <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div>
<p>所有这三个请求都满足“路由定义”中设置的所有条件。</p>

<p>但是，以下请求将<strong>不</strong>符合配置的条件：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div>
<blockquote>
<p>路径未匹配。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">POST</span> /foo <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div>
<blockquote>
<p>请求方法未匹配。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /foo <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> foo.com</code></pre></div>
<blockquote>
<p>URL未匹配。</p>
</blockquote>

<p>所有这三个请求仅满足两个已配置的条件。第一个请求的路径与任何已配置的都不匹配，<code>paths</code>第二个请求的HTTP方法与第三个请求的Host标头相同。</p>

<p>现在我们了解了路由属性如何协同工作，让我们分别探讨每个属性。</p>

<h4 id="preserve-host-属性"><code>preserve_host</code> 属性</h4>

<p>代理时，Kong的默认行为是将上游请求的Host标头设置为Service的中指定的主机名<code>host</code>。该<code>preserve_host</code>字段接受一个布尔型标志，指示Kong不这样做。</p>

<p>例如，当<code>preserve_host</code>属性未更改且路由配置如下时：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;hosts&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;service.com&#34;</span>],
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>客户对Kong的可能请求可能是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> service.com</code></pre></div>
<p>Kong将从Service的<code>host</code>属性中提取Host标头值，并将发送以下上游请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> &lt;my-service-host.com&gt;</code></pre></div>
<p>但是，通过显式配置Route <code>preserve_host=true</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;hosts&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;service.com&#34;</span>],
    <span style="color:#f1fa8c">&#34;preserve_host&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>,
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>并假设来自客户端的相同请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> service.com</code></pre></div>
<p>Kong将保留客户端请求上的主机，并改为发送以下上游请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> service.com</code></pre></div>
<h4 id="扩展request-headers-except-host">扩展Request headers (except Host)</h4>

<p>从Kong 1.3.0开始，可以通过以外的其他报头来路由请求<code>Host</code>。</p>

<p>为此，可以通过<code>headers</code>来配置扩展的信息，如下扩展了<code>version</code>信息：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;headers&#34;</span><span style="color:#ff79c6">:</span> { <span style="color:#f1fa8c">&#34;version&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;v1&#34;</span>, <span style="color:#f1fa8c">&#34;v2&#34;</span>] },
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>给定带有扩展header的请求，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
version<span style="color:#ff79c6">:</span> v1</code></pre></div>
<p>如下的请求也将被路由到服务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
version<span style="color:#ff79c6">:</span> v2</code></pre></div>
<p>但是，如下的请求不会路由到服务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
version<span style="color:#ff79c6">:</span> v3</code></pre></div>
<p><strong>注意</strong>：<code>headers</code>键是逻辑<code>AND</code>关系，其值是逻辑<code>OR</code>关系。</p>

<h4 id="请求路径paths">请求路径paths</h4>

<p>路由匹配的另一种方法是通过请求路径。为了满足此路由条件，客户端请求的路径<strong>必须</strong>以<code>paths</code>属性值之一为前缀。</p>

<p>例如，使用如下配置的路由：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http">{
    &#34;paths&#34;: [&#34;/service&#34;, &#34;/hello/world&#34;]
}</code></pre></div>
<p>以下请求将被匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /service <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /service/resource?param=value <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /hello/world/resource <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> anything.com</code></pre></div>
<p>对于这些请求中的每一个，Kong都会检测到其URL路径以 <code>paths</code>值之一为前缀。默认情况下，Kong然后将在不更改URL路径的情况下向上游代理请求。</p>

<p>使用路径前缀代理时，<strong>最长的路径将首先被评估</strong>。也就是这样的两个路径：<code>/service</code>和<code>/service/resource</code>，前者并不会“覆盖”后者。</p>

<h4 id="在-paths-中使用正则表达式">在<code>paths</code>中使用正则表达式</h4>

<p>Kong <code>paths</code>通过<a href="http://pcre.org/">PCRE</a>（Perl兼容正则表达式）支持路由字段的正则表达式模式匹配。您可以同时将路径作为前缀和正则表达式分配给路由。</p>

<p>例如，如下的<code>paths</code>配置：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;paths&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;/users/\d+/profile&#34;</span>, <span style="color:#f1fa8c">&#34;/following&#34;</span>]
}</code></pre></div>
<p>下列的请求将被匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /following <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /users/123/profile <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div>
<p>所提供的正则表达式使用<code>a</code>PCRE标志（<code>PCRE_ANCHORED</code>）进行评估，也就是它们将被约束为在路径的第一个匹配点（根<code>/</code>字符）匹配。</p>

<h4 id="strip-path-属性"><code>strip_path</code> 属性</h4>

<p>在配置路由时，指定了对应的路径前缀，但又不希望其包括在上游请求中。为此，可<code>strip_path</code>通过配置Route来使用boolean属性，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;paths&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;/service&#34;</span>],
    <span style="color:#f1fa8c">&#34;strip_path&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>,
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>启用此标志指示Kong所匹配的路由<code>paths</code>信息，在代理处理时它<strong>不</strong>应该包括在上游请求的URL的URL路径的匹配部分。</p>

<p>例如，如下的请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /service/path/to/resource <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div>
<p>Kong将发送以下上游请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /path/to/resource <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div>
<p>同样，如果在已<code>strip_path</code>启用的Route上定义了正则表达式路径，则将剥离请求URL匹配序列的全部。例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;paths&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;/version/\d+/service&#34;</span>],
    <span style="color:#f1fa8c">&#34;strip_path&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#ff79c6">true</span>,
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>以下HTTP请求与提供的正则表达式路径匹配：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /version/1/service/path/to/resource <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div>
<p>Kong将在上游代理为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> /path/to/resource <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> ...</code></pre></div>
<h4 id="匹配优先级规则">匹配优先级规则</h4>

<p>一条路线可以基于其定义匹配规则<code>headers</code>，<code>hosts</code>，<code>paths</code>，和<code>methods</code>（加<code>snis</code>-用于安全的路线<code>&quot;https&quot;</code>，<code>&quot;grpcs&quot;</code>，<code>&quot;tls&quot;</code>字段）。为了使Kong将传入请求匹配到Route，必须满足所有现有字段。但是，Kong允许通过使用包含相同值的字段配置两个或更多路由来提供相当大的灵活性-发生这种情况时，Kong将应用优先级规则。</p>

<p>规则是：<strong>在匹配评估请求时，Kong首先会尝试将规则最多的路线进行匹配</strong>。</p>

<p>例如，有两个路由配置如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;hosts&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;example.com&#34;</span>],
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
},
{
    <span style="color:#f1fa8c">&#34;hosts&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;example.com&#34;</span>],
    <span style="color:#f1fa8c">&#34;methods&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;POST&#34;</span>],
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>第二条路线有一个<code>hosts</code>字段<strong>和</strong>一个<code>methods</code>字段，因此它将首先由Kong进行匹配评估。这样，我们避免了针对第二个路线的第一个路线“影子”调用。</p>

<p>如下请求将匹配第一个路线</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">GET</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div>
<p>如下请求将匹配第二个请求：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-http" data-lang="http"><span style="color:#50fa7b">POST</span> / <span style="color:#ff79c6">HTTP</span><span style="color:#ff79c6">/</span><span style="color:#bd93f9">1.1</span>
Host<span style="color:#ff79c6">:</span> example.com</code></pre></div>
<p>按照此逻辑，如果要为第三条路线配置一个<code>hosts</code>字段，一个<code>methods</code>字段和一个<code>uris</code>字段，则Kong将首先对其进行评估。</p>

<p>[TODO]如果给定请求的规则数在<code>A</code>和<code>B</code>两个路由相同，则以下所列规则将按照列出的顺序匹配。如果满足以下条件，<code>B</code>将优先于<code>A</code>：</p>

<ul>
<li><code>A</code>仅具有“普通”header配置，<code>B</code>并且具有一个或多个“通配符”header配置。</li>
<li><code>A</code> 比 <code>B</code>有更多的非<code>hosts</code>的属性.</li>
<li><code>A</code>具有至少一个“正则表达式”路径，<code>B</code>而只有“纯”路径。</li>
<li><code>A</code>的更长路径比<code>B</code>更长的路径更长。</li>
<li><code>A.created_at &lt; B.created_at</code></li>
</ul>

<h4 id="代理行为-https-docs-konghq-com-2-1-x-proxy-proxying-behavior">代理行为 (<a href="https://docs.konghq.com/2.1.x/proxy/#proxying-behavior">https://docs.konghq.com/2.1.x/proxy/#proxying-behavior</a>)</h4>

<h4 id="配置一个备用路由-https-docs-konghq-com-2-1-x-proxy-configuring-a-fallback-route">配置一个备用路由 (<a href="https://docs.konghq.com/2.1.x/proxy/#configuring-a-fallback-route">https://docs.konghq.com/2.1.x/proxy/#configuring-a-fallback-route</a>)</h4>

<p>实现“后备路由”，可以避免Kong在HTTP响应<code>404</code>时出现“找不到路由”，我们可以捕获此类请求并将其代理到特殊的上游服务，或对其应用插件（例如，该插件可以使用其他状态代码或响应终止请求，而无需代理请求）。</p>

<p>一个后备路由的示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">{
    <span style="color:#f1fa8c">&#34;paths&#34;</span><span style="color:#ff79c6">:</span> [<span style="color:#f1fa8c">&#34;/&#34;</span>],
    <span style="color:#f1fa8c">&#34;service&#34;</span><span style="color:#ff79c6">:</span> {
        <span style="color:#f1fa8c">&#34;id&#34;</span><span style="color:#ff79c6">:</span> <span style="color:#f1fa8c">&#34;...&#34;</span>
    }
}</code></pre></div>
<p>当向Kong发出的任何HTTP请求实际上都将与此路由匹配，因为所有URI都以根字符为前缀<code>/</code>。从“请求路径”部分我们知道，最长的URL路径首先由Kong评估，因此该<code>/</code>路径最终将最终由Kong评估，并有效地提供了“后备”路线，仅在万不得已时才进行匹配。然后，您可以将流量发送到特殊服务，或在此路线上应用您希望的任何插件。</p>

<h4 id="websocket-代理-https-docs-konghq-com-2-1-x-proxy-proxy-websocket-traffic-todo">WebSocket 代理 (<a href="https://docs.konghq.com/2.1.x/proxy/#proxy-websocket-traffic)(TODO">https://docs.konghq.com/2.1.x/proxy/#proxy-websocket-traffic)(TODO</a>)</h4>

<h3 id="负载均衡-https-docs-konghq-com-2-1-x-loadbalancing">负载均衡 (<a href="https://docs.konghq.com/2.1.x/loadbalancing/">https://docs.konghq.com/2.1.x/loadbalancing/</a>)</h3>

<h4 id="基于dns的负载平衡">基于DNS的负载平衡</h4>

<blockquote>
<p>后端服务的注册是在Kong之外进行的。</p>
</blockquote>

<h4 id="ring-balancer">Ring-balancer</h4>

<p>算法选择: <code>consistent-hashing</code>, <code>least-connections</code>, <code>round-robin</code></p>

<h4 id="blue-green-发布-https-docs-konghq-com-2-1-x-loadbalancing-blue-green-deployments">Blue-Green 发布 (<a href="https://docs.konghq.com/2.1.x/loadbalancing/#blue-green-deployments">https://docs.konghq.com/2.1.x/loadbalancing/#blue-green-deployments</a>)</h4>

<p>扩展: (<a href="https://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/">https://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/</a>)</p>

<p><img src="https://izcqi.com/images/image-20200728144535998.png#mid" alt="Blue-Green Deployment" /></p>

<p>使用 ring-balance，可以轻松地为服务编排蓝绿色部署。切换目标基础架构仅需要<code>PATCH</code>对服务的请求即可更改其<code>host</code>价值。</p>

<ul>
<li><p>设置“Blue”环境，运行地址服务的版本1：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#6272a4"># create an upstream</span>
$ curl -X POST http://kong:8001/upstreams <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;name=address.v1.service&#34;</span>
  
<span style="color:#6272a4"># add two targets to the upstream</span>
$ curl -X POST http://kong:8001/upstreams/address.v1.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;target=192.168.34.15:80&#34;</span>
  --data <span style="color:#f1fa8c">&#34;weight=100&#34;</span>
$ curl -X POST http://kong:8001/upstreams/address.v1.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;target=192.168.34.16:80&#34;</span>
  --data <span style="color:#f1fa8c">&#34;weight=50&#34;</span>
  
<span style="color:#6272a4"># create a Service targeting the Blue upstream</span>
$ curl -X POST http://kong:8001/services/ <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;name=address-service&#34;</span> <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;host=address.v1.service&#34;</span> <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;path=/address&#34;</span>
  
<span style="color:#6272a4"># finally, add a Route as an entry-point into the Service</span>
$ curl -X POST http://kong:8001/services/address-service/routes/ <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;hosts[]=address.mydomain.com&#34;</span></code></pre></div></li>
</ul>

<blockquote>
<p>主机头设置为的请求<code>address.mydomain.com</code>将由Kong代理到两个已定义的目标；2 / 3的请求将去<code>http://192.168.34.15:80/address</code>（<code>weight=100</code>），和1 / 3将去<code>http://192.168.34.16:80/address</code>（<code>weight=50</code>）。</p>
</blockquote>

<ul>
<li><p>在部署地址服务的版本2之前，请设置“Green”环境：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#6272a4"># create a new Green upstream for address service v2</span>
$ curl -X POST http://kong:8001/upstreams <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;name=address.v2.service&#34;</span>
  
<span style="color:#6272a4"># add targets to the upstream</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;target=192.168.34.17:80&#34;</span>
  --data <span style="color:#f1fa8c">&#34;weight=100&#34;</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>  --data <span style="color:#f1fa8c">&#34;target=192.168.34.18:80&#34;</span>
  --data <span style="color:#f1fa8c">&#34;weight=100&#34;</span></code></pre></div></li>
</ul>

<p>要激活Blue/Green 开关，我们现在只需要更新服务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">  <span style="color:#6272a4"># Switch the Service from Blue to Green upstream, v1 -&gt; v2</span>
  $ curl -X PATCH http://kong:8001/services/address-service <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>      --data <span style="color:#f1fa8c">&#34;host=address.v2.service&#34;</span></code></pre></div>
<blockquote>
<blockquote>
<p>主机头设置为的传入请求<code>address.mydomain.com</code>将由Kong代理到新目标；1 / 2的请求将去<code>http://192.168.34.17:80/address</code>（<code>weight=100</code>），以及其它1 / 2将去<code>http://192.168.34.18:80/address</code>（<code>weight=100</code>）。</p>
</blockquote>
</blockquote>

<h4 id="canary-releases-https-docs-konghq-com-2-1-x-loadbalancing-canary-releases">Canary Releases (<a href="https://docs.konghq.com/2.1.x/loadbalancing/#canary-releases">https://docs.konghq.com/2.1.x/loadbalancing/#canary-releases</a>)</h4>

<p>Extension: (<a href="http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/">http://blog.christianposta.com/deploy/blue-green-deployments-a-b-testing-and-canary-releases/</a>)</p>

<p>Using the ring-balancer, target weights can be adjusted granularly, allowing for a smooth, controlled canary release.</p>

<p>Using a very simple 2 target example:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#6272a4"># first target at 1000</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>    --data <span style="color:#f1fa8c">&#34;target=192.168.34.17:80&#34;</span>
    --data <span style="color:#f1fa8c">&#34;weight=1000&#34;</span>

<span style="color:#6272a4"># second target at 0</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>    --data <span style="color:#f1fa8c">&#34;target=192.168.34.18:80&#34;</span>
    --data <span style="color:#f1fa8c">&#34;weight=0&#34;</span></code></pre></div>
<p>By repeating the requests, but altering the weights each time, traffic will slowly be routed towards the other target. For example, set it at 10%:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#6272a4"># first target at 900</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>    --data <span style="color:#f1fa8c">&#34;target=192.168.34.17:80&#34;</span>
    --data <span style="color:#f1fa8c">&#34;weight=900&#34;</span>

<span style="color:#6272a4"># second target at 100</span>
$ curl -X POST http://kong:8001/upstreams/address.v2.service/targets <span style="color:#f1fa8c">\
</span><span style="color:#f1fa8c"></span>    --data <span style="color:#f1fa8c">&#34;target=192.168.34.18:80&#34;</span>
    --data <span style="color:#f1fa8c">&#34;weight=100&#34;</span></code></pre></div>
<p>The changes through the Kong Admin API are dynamic and will take effect immediately. No reload or restart is required, and no in progress requests will be dropped.</p>

<h3 id="health-checks-and-circuit-breakers-reference-https-docs-konghq-com-2-1-x-health-checks-circuit-breakers">Health Checks and Circuit Breakers Reference (<a href="https://docs.konghq.com/2.1.x/health-checks-circuit-breakers/">https://docs.konghq.com/2.1.x/health-checks-circuit-breakers/</a>)</h3>

<h4 id="upstreams">Upstreams</h4>

<p>Along with health check functionality on individual targets, Upstreams also have a notion of health. The health of an Upstream is determined based on the status of its Targets.</p>

<p>Configuration of the Upstream’s health is done though the property <code>healthchecks.threshold</code>. This is a percentage of minimum available target “weight” (capacity) for the Upstream to be considered healthy.</p>

<p>Here is a simple example:</p>

<ul>
<li>Assume an Upstream configured with <code>healthchecks.threshold=55</code>.</li>
<li>It has 5 targets, each with <code>weight=100</code>, so the total weight in the ring-balancer is 500.</li>
</ul>

<p>When failures start to occur, the circuit-breaker for the first target trips. It is now considered unhealthy. This means that in the ring-balancer, 20% of the capacity is now unhealthy (100 weight out of 500). This is still above the threshold of 55, so the remaining targets will serve the traffic of the failed one.</p>

<p>When a second failure occurs, another target fails, and another 100 weight is lost as unhealthy. Now the ring-balancer operates at 60% of its capacity, but still within the configured threshold.</p>

<p>If we assume that the 2 failures occured due to a system overload, we can now assume that the remaining 60% will also not be able to cope with the full load and soon a third node will fail, reducing healthy capacity to 40%. At this point, the Upstream health will be less than its threshold, and it will be marked as unhealthy itself.</p>

<p>Once it enters an unhealthy state, the Upstream will only return errors. This lets the targets/services recover from the cascading failure they were experiencing.</p>

<p>Once the Targets start recovering and the Upstream’s available capacity passes the threshold again, the health status of the ring-balancer will automatically be updated.</p>

<h4 id="types-of-health-checks">Types of health checks</h4>

<ul>
<li>Active health checks</li>
</ul>

<p>Active health checks, as the name implies, actively probe targets for their health. When active health checks are enabled in an upstream entity, Kong will periodically issue HTTP or HTTPS requests to a configured path at each target of the upstream. This allows Kong to automatically enable and disable targets in the balancer based on the probe results.</p>

<p>The periodicity of active health checks can be configured separately for when a target is healthy or unhealthy. If the <code>interval</code> value for either is set to zero, the checking is disabled at the corresponding scenario. When both are zero, active health checks are disabled altogether.</p>

<ul>
<li>Passive health checks (circuit breakers)</li>
</ul>

<h3 id="clustering-reference-https-docs-konghq-com-2-1-x-clustering">Clustering Reference  (<a href="https://docs.konghq.com/2.1.x/clustering/">https://docs.konghq.com/2.1.x/clustering/</a>)</h3>

<p>A Kong cluster allows you to scale the system horizontally by adding more machines to handle more incoming requests. They will all share the same configuration since they point to the same database. Kong nodes pointing to the <strong>same datastore</strong> will be part of the same Kong cluster.</p>

<p>You need a load-balancer in front of your Kong cluster to distribute traffic across your available nodes.</p>

<h4 id="multiple-nodes-kong-clusters">Multiple nodes Kong clusters</h4>

<p>Every <code>db_update_frequency</code> seconds, all running Kong nodes will poll the database for any update, and will purge the relevant entities from their cache if necessary.</p>

<p>If we delete a Service from node <code>A</code>, this change will not be effective in node <code>B</code> until node <code>B</code>s next database poll, which will occur up to <code>db_update_frequency</code> seconds later (though it could happen sooner).</p>

<h4 id="what-is-being-cached">What is being cached?</h4>

<p>All of the core entities such as Services, Routes, Plugins, Consumers, Credentials are cached in memory by Kong and depend on their invalidation via the polling mechanism to be updated.</p>

<h4 id="how-to-configure-database-caching">How to configure database caching?</h4>

<p>You can configure 3 properties in the Kong configuration file, the most important one being db_update_frequency, which determine where your Kong nodes stand on the performance vs consistency trade off.</p>

<p>Kong comes with default values tuned for consistency, in order to let you experiment with its clustering capabilities while avoiding “surprises”. As you prepare a production setup, you should consider tuning those values to ensure that your performance constraints are respected.</p>

<ul>
<li><code>db_update_frequency</code> (default: 5s)
This value determines the frequency at which your Kong nodes will be polling the database for invalidation events. A lower value will mean that the polling job will be executed more frequently, but that your Kong nodes will keep up with changes you apply. A higher value will mean that your Kong nodes will spend less time running the polling jobs, and will focus on proxying your traffic.</li>
</ul>

<blockquote>
<p>Note: changes propagate through the cluster in up to db_update_frequency seconds.</p>
</blockquote>

<ul>
<li><code>db_update_propagation</code> (default: 0s)
If your database itself is eventually consistent (ie: Cassandra), you must configure this value. It is to ensure that the change has time to propagate across your database nodes. When set, Kong nodes receiving invalidation events from their polling jobs will delay the purging of their cache for db_update_propagation seconds.</li>
</ul>

<p>If a Kong node connected to an eventual consistent database was not delaying the event handling, it could purge its cache, only to cache the non-updated value again (because the change hasn’t propagated through the database yet)!</p>

<p>You should set this value to an estimate of the amount of time your database cluster takes to propagate changes.</p>

<blockquote>
<p>Note: when this value is set, changes propagate through the cluster in up to db_update_frequency + db_update_propagation seconds.</p>
</blockquote>

<ul>
<li><code>db_cache_ttl</code> (default: 0s)
The time (in seconds) for which Kong will cache database entities (both hits and misses). This Time-To-Live value acts as a safeguard in case a Kong node misses an invalidation event, to avoid it from running on stale data for too long. When the TTL is reached, the value will be purged from its cache, and the next database result will be cached again.</li>
</ul>

<p>By default no data is invalidated based on this TTL (the default value is 0). This is usually fine: Kong nodes rely on invalidation events, which are handled at the db store level (Cassandra/PosgreSQL). If you are concerned that a Kong node might miss invalidation event for any reason, you should set a TTL. Otherwise the node might run with a stale value in its cache for an undefined amount of time, until the cache is manually purged, or the node is restarted.</p>

<ul>
<li>When using Cassandra</li>
</ul>

<p>If you use Cassandra as your Kong database, you <strong>must</strong> set <code>db_update_propagation</code> to a non-zero value. Since Cassandra is eventually consistent by nature, this will ensure that Kong nodes do not prematurely invalidate their cache, only to fetch and catch a not up-to-date entity again. Kong will present you a warning logs if you did not configure this value when using Cassandra.</p>

<p>Additionally, you might want to configure <code>cassandra_consistency</code> to a value like <code>QUORUM</code> or <code>LOCAL_QUORUM</code>, to ensure that values being cached by your Kong nodes are up-to-date values from your database.</p>

<p>Setting the <code>cassandra_refresh_frequency</code> option to <code>0</code> is not advised, as a Kong restart will be required to discover any changes to the Cassandra cluster topology.</p>

<h3 id="network-firewall-https-docs-konghq-com-2-1-x-network-firewall">Network Firewall  (<a href="https://docs.konghq.com/2.1.x/network/#firewall">https://docs.konghq.com/2.1.x/network/#firewall</a>)</h3>

<h4 id="transparent-proxying-https-blog-stackpath-com-transparent-proxy">Transparent Proxying (<a href="https://blog.stackpath.com/transparent-proxy/">https://blog.stackpath.com/transparent-proxy/</a>)</h4>

<p>For example a HTTP request with a destination address of <code>10.0.0.1</code>, and a destination port of <code>80</code> can be redirected to <code>127.0.0.1</code> at port <code>8000</code>. To make this work, you need (with Linux) to add the <code>transparent</code> listen option to Kong proxy, <code>proxy_listen=8000 transparent</code>. This allows Kong to see the original destination for the request (<code>10.0.0.1:80</code>) even when Kong didn’t actually listen to it directly. With this information, Kong can route the request correctly. The <code>transparent</code> listen option should only be used with Linux. macOS/BSDs allow transparent proxying without <code>transparent</code> listen option. With Linux you may also need to start Kong as a <code>root</code> user or set the needed capabilities for the executable.</p>

<p><img src="https://izcqi.com/images/image-20200728094209364.png#mid" alt="Transparent Proxy" /></p>

<h3 id="control-kong-through-systemd">Control Kong through systemd</h3>

<h5 id="customize-kong-s-nginx-instance-including-files-via-the-injected-nginx-directives-https-docs-konghq-com-2-1-x-systemd-customize-kongs-nginx-instance-including-files-via-the-injected-nginx-directives">Customize Kong’s Nginx instance including files via the injected Nginx directives  (<a href="https://docs.konghq.com/2.1.x/systemd/#customize-kongs-nginx-instance-including-files-via-the-injected-nginx-directives">https://docs.konghq.com/2.1.x/systemd/#customize-kongs-nginx-instance-including-files-via-the-injected-nginx-directives</a>)</h5>

<h3 id="plugins-execution-order">Plugins execution order</h3>

<p>The current order of execution for the bundled plugins is:</p>

<table>
<thead>
<tr>
<th align="left">Plugin</th>
<th align="left">Priority</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">pre-function</td>
<td align="left"><code>+inf</code></td>
</tr>

<tr>
<td align="left">zipkin</td>
<td align="left">100000</td>
</tr>

<tr>
<td align="left">ip-restriction</td>
<td align="left">3000</td>
</tr>

<tr>
<td align="left">bot-detection</td>
<td align="left">2500</td>
</tr>

<tr>
<td align="left">cors</td>
<td align="left">2000</td>
</tr>

<tr>
<td align="left">session</td>
<td align="left">1900</td>
</tr>

<tr>
<td align="left">kubernetes-sidecar-injector</td>
<td align="left">1006</td>
</tr>

<tr>
<td align="left">jwt</td>
<td align="left">1005</td>
</tr>

<tr>
<td align="left">oauth2</td>
<td align="left">1004</td>
</tr>

<tr>
<td align="left">key-auth</td>
<td align="left">1003</td>
</tr>

<tr>
<td align="left">ldap-auth</td>
<td align="left">1002</td>
</tr>

<tr>
<td align="left">basic-auth</td>
<td align="left">1001</td>
</tr>

<tr>
<td align="left">hmac-auth</td>
<td align="left">1000</td>
</tr>

<tr>
<td align="left">request-size-limiting</td>
<td align="left">951</td>
</tr>

<tr>
<td align="left">acl</td>
<td align="left">950</td>
</tr>

<tr>
<td align="left">rate-limiting</td>
<td align="left">901</td>
</tr>

<tr>
<td align="left">response-ratelimiting</td>
<td align="left">900</td>
</tr>

<tr>
<td align="left">request-transformer</td>
<td align="left">801</td>
</tr>

<tr>
<td align="left">response-transformer</td>
<td align="left">800</td>
</tr>

<tr>
<td align="left">aws-lambda</td>
<td align="left">750</td>
</tr>

<tr>
<td align="left">azure-functions</td>
<td align="left">749</td>
</tr>

<tr>
<td align="left">prometheus</td>
<td align="left">13</td>
</tr>

<tr>
<td align="left">http-log</td>
<td align="left">12</td>
</tr>

<tr>
<td align="left">statsd</td>
<td align="left">11</td>
</tr>

<tr>
<td align="left">datadog</td>
<td align="left">10</td>
</tr>

<tr>
<td align="left">file-log</td>
<td align="left">9</td>
</tr>

<tr>
<td align="left">udp-log</td>
<td align="left">8</td>
</tr>

<tr>
<td align="left">tcp-log</td>
<td align="left">7</td>
</tr>

<tr>
<td align="left">loggly</td>
<td align="left">6</td>
</tr>

<tr>
<td align="left">syslog</td>
<td align="left">4</td>
</tr>

<tr>
<td align="left">request-termination</td>
<td align="left">2</td>
</tr>

<tr>
<td align="left">correlation-id</td>
<td align="left">1</td>
</tr>

<tr>
<td align="left">post-function</td>
<td align="left">-1000</td>
</tr>
</tbody>
</table>

<h3 id="importment-settings">Importment Settings</h3>

<h4 id="upstreams-1">Upstreams</h4>

<ul>
<li><code>healthchecks.active.healthy.interval</code> default and set to <code>0</code> that active probes for <code>healthy targets</code> should not be performed.</li>
<li><code>healthchecks.active.unhealthy.interval</code> default and set to  <code>0</code> that active probes for <code>unhealthy targets</code> should not be performed.</li>
</ul>

<h4 id="kong-config">kong.config</h4>

<ul>
<li><code>healthchecks.active.healthy.interval</code> cannot set <code>0</code> that active probes for healthy targets should not be performed.</li>
<li><code>healthchecks.active.unhealthy.interval</code> cannot set to  <code>0</code> that active probes for unhealthy targets should not be performed.</li>
</ul>


</article>

<script src="https://utteranc.es/client.js"
    repo="qicz/ThoughtsHUB"
    issue-term="pathname"
    theme="github-light"
    crossorigin="anonymous"
    async>
</script>

<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://izcqi.com/posts/2020/07/28/kong-quick-start-and-core-concepts-en/"><i class="fa fa-chevron-circle-left"></i> Kong Quick Start &amp; Core Concepts (En) </a>
        </li>
        
        
    </ul>
</section>
    




</main>
    <footer>
        <h6>&copy; 2012 - 2020 Qicz 
            - Qicz&#39;s Thoughts HUB (<a href="https://izcqi.com/"> https://izcqi.com</a>)
            | Theme <a href="https://github.com/qicz/qicz-hugo-theme">qicz-theme</a>
            | This site USES <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a></h6>
    </footer>
</div>

<script async src="https://izcqi.com/js/busuanzi.pure.mini.js"></script>

</body>

</html>

